{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app import routes\n\napp = FastAPI(\n    title=\"Calculator API\",\n    description=\"A simple API for basic arithmetic operations.\",\n    version=\"1.0.0\",\n)\n\napp.include_router(routes.router)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Welcome to the Calculator API. Use /calculate to perform operations.\"}"}, {"path": "app/database.py", "content": "from typing import Generator\n\nfrom sqlmodel import Session, SQLModel, create_engine\n\n# This is a placeholder file.\n# For this stateless calculator API, no actual database is used.\n# However, if this project were to expand to include persistence,\n# this file would contain the database engine and session management.\n\n# Example of what it would look like if a database were used:\n# DATABASE_URL = \"sqlite:///./database.db\"\n# engine = create_engine(DATABASE_URL, echo=True)\n\n# def create_db_and_tables():\n#     SQLModel.metadata.create_all(engine)\n\n# def get_session() -> Generator[Session, None, None]:\n#     with Session(engine) as session:\n#         yield session\n\n# For now, we'll keep it minimal as per the stateless requirement.\n# We define a dummy engine and session for type hinting consistency\n# if other parts of the application were designed to expect them,\n# but they won't be used in this specific calculator implementation.\n\nclass DummySession:\n    \"\"\"A dummy session class for when no database is actually used.\"\"\"\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\ndef get_session() -> Generator[DummySession, None, None]:\n    \"\"\"\n    A dummy session generator.\n    Yields a dummy session object, as no real database session is needed\n    for this stateless calculator API.\n    \"\"\"\n    yield DummySession()\n\n# No actual database engine or tables are created for this project's current scope."}, {"path": "app/models.py", "content": "# This file is a placeholder for SQLModel models.\n# For this stateless API, no database models are required."}, {"path": "app/schemas.py", "content": "from pydantic import BaseModel, Field\n\nclass CalculationRequest(BaseModel):\n    operand1: float = Field(..., description=\"The first operand for the calculation.\")\n    operand2: float = Field(..., description=\"The second operand for the calculation.\")\n    operation: str = Field(..., description=\"The arithmetic operation to perform (e.g., 'add', 'subtract', 'multiply', 'divide').\")\n\nclass CalculationResponse(BaseModel):\n    result: float = Field(..., description=\"The result of the calculation.\")"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, HTTPException, status\nfrom app.schemas import CalculationRequest, CalculationResponse\nfrom app.services import CalculatorService\n\nrouter = APIRouter()\ncalculator_service = CalculatorService()\n\n@router.post(\"/calculate\", response_model=CalculationResponse)\nasync def calculate_operation(request: CalculationRequest):\n    try:\n        result = calculator_service.perform_calculation(\n            operand1=request.operand1,\n            operand2=request.operand2,\n            operation=request.operation\n        )\n        return CalculationResponse(result=result)\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )"}, {"path": "app/services.py", "content": "from fastapi import HTTPException, status\n\nclass CalculatorService:\n    def perform_calculation(self, operand1: float, operand2: float, operation: str) -> float:\n        if operation == \"add\":\n            return self._add(operand1, operand2)\n        elif operation == \"subtract\":\n            return self._subtract(operand1, operand2)\n        elif operation == \"multiply\":\n            return self._multiply(operand1, operand2)\n        elif operation == \"divide\":\n            return self._divide(operand1, operand2)\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid operation. Supported operations are: add, subtract, multiply, divide.\"\n            )\n\n    def _add(self, operand1: float, operand2: float) -> float:\n        return operand1 + operand2\n\n    def _subtract(self, operand1: float, operand2: float) -> float:\n        return operand1 - operand2\n\n    def _multiply(self, operand1: float, operand2: float) -> float:\n        return operand1 * operand2\n\n    def _divide(self, operand1: float, operand2: float) -> float:\n        if operand2 == 0:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Division by zero is not allowed.\"\n            )\n        return operand1 / operand2"}, {"path": "app/auth.py", "content": "from typing import Annotated\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\n# In a real application, these would be loaded from environment variables\nSECRET_KEY = \"super-secret-key\"  # pragma: allowlist secret\nALGORITHM = \"HS256\"\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict) -> str:\n    to_encode = data.copy()\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\ndef get_current_user(token: Annotated[str, Depends(oauth2_scheme)]) -> str:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        return username\n    except JWTError:\n        raise credentials_exception"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}