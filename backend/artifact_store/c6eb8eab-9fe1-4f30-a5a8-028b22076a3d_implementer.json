{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.database import engine\nfrom app.models import Todo\nfrom app.routes import router as api_router\n\n\ndef create_db_tables():\n    \"\"\"Create all database tables on startup.\"\"\"\n    Todo.metadata.create_all(bind=engine)\n\n\napp = FastAPI(\n    title=\"Todo Application\",\n    description=\"A simple todo application API\",\n    version=\"1.0.0\"\n)\n\napp.include_router(api_router)\n\n\n@app.on_event(\"startup\")\ndef on_startup():\n    create_db_tables()\n\n\n@app.get(\"/\")\ndef root():\n    return {\"message\": \"Todo Application API\", \"status\": \"running\"}\n\n\n@app.get(\"/health\")\ndef health_check():\n    return {\"status\": \"healthy\"}"}, {"path": "app/database.py", "content": "from sqlmodel import Session, SQLModel, create_engine\nfrom typing import Generator\n\n# Database URL - using SQLite by default\nDATABASE_URL = \"sqlite:///./todo.db\"\n\n# Create engine with specific settings for SQLite\nengine = create_engine(\n    DATABASE_URL,\n    echo=False,\n    connect_args={\"check_same_thread\": False}  # Required for SQLite\n)\n\n\ndef create_db_and_tables() -> None:\n    \"\"\"Create all database tables.\"\"\"\n    SQLModel.metadata.create_all(engine)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency for getting database session.\n    Yields a session and ensures it's closed after use.\n    \"\"\"\n    with Session(engine) as session:\n        yield session\n</content>"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Todo(SQLModel, table=True):\n    \"\"\"Todo entity representing a task item.\"\"\"\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(min_length=1, max_length=255)\n    description: Optional[str] = Field(default=None, max_length=1000)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\n\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., min_length=1, description=\"Title of the todo item\")\n    description: Optional[str] = Field(None, description=\"Description of the todo item\")\n    completed: bool = Field(default=False, description=\"Completion status of the todo item\")\n\n\nclass TodoCreate(TodoBase):\n    \"\"\"Schema for creating a new todo item.\"\"\"\n    pass\n\n\nclass TodoUpdate(BaseModel):\n    \"\"\"Schema for updating an existing todo item.\"\"\"\n    title: Optional[str] = Field(None, min_length=1, description=\"Title of the todo item\")\n    description: Optional[str] = Field(None, description=\"Description of the todo item\")\n    completed: Optional[bool] = Field(None, description=\"Completion status of the todo item\")\n\n\nclass TodoResponse(TodoBase):\n    \"\"\"Schema for todo item response.\"\"\"\n    id: str = Field(..., description=\"Unique identifier of the todo item\")\n    created_at: datetime = Field(..., description=\"Timestamp when the todo item was created\")\n    updated_at: datetime = Field(..., description=\"Timestamp when the todo item was last updated\")\n\n    class Config:\n        from_attributes = True\n        json_schema_extra = {\n            \"example\": {\n                \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n                \"title\": \"Buy groceries\",\n                \"description\": \"Milk, bread, eggs, butter\",\n                \"completed\": False,\n                \"created_at\": \"2024-01-15T10:30:00\",\n                \"updated_at\": \"2024-01-15T10:30:00\"\n            }\n        }\n\n\nclass TodoListResponse(BaseModel):\n    \"\"\"Schema for list of todo items response.\"\"\"\n    todos: list[TodoResponse] = Field(default_factory=list, description=\"List of todo items\")\n    total: int = Field(..., description=\"Total number of todo items\")"}, {"path": "app/repositories/todo_repository.py", "content": "from typing import List, Optional\nfrom sqlmodel import Session, select\n\nfrom app.models import Todo\n\n\nclass TodoRepository:\n    def __init__(self, session: Session):\n        self.session = session\n\n    def create(self, todo: Todo) -> Todo:\n        self.session.add(todo)\n        self.session.commit()\n        self.session.refresh(todo)\n        return todo\n\n    def get_all(self) -> List[Todo]:\n        statement = select(Todo)\n        return list(self.session.exec(statement).all())\n\n    def get_by_id(self, todo_id: str) -> Optional[Todo]:\n        statement = select(Todo).where(Todo.id == todo_id)\n        return self.session.exec(statement).first()\n\n    def update(self, todo: Todo) -> Todo:\n        self.session.add(todo)\n        self.session.commit()\n        self.session.refresh(todo)\n        return todo\n\n    def delete(self, todo: Todo) -> None:\n        self.session.delete(todo)\n        self.session.commit()"}, {"path": "app/services/todo_service.py", "content": "from typing import List, Optional\nfrom sqlmodel import Session\n\nfrom app.models import Todo\nfrom app.repositories.todo_repository import TodoRepository\nfrom app.schemas import TodoCreate, TodoUpdate\n\n\nclass TodoService:\n    def __init__(self, session: Session):\n        self.repository = TodoRepository(session)\n\n    def create_todo(self, todo_data: TodoCreate) -> Todo:\n        \"\"\"Create a new todo item with business logic validation.\"\"\"\n        if not todo_data.title or not todo_data.title.strip():\n            raise ValueError(\"Title is required for a new todo item\")\n        \n        todo = Todo(\n            title=todo_data.title.strip(),\n            description=todo_data.description,\n            completed=todo_data.completed if todo_data.completed is not None else False\n        )\n        \n        return self.repository.create(todo)\n\n    def get_all_todos(self) -> List[Todo]:\n        \"\"\"Retrieve all todo items.\"\"\"\n        return self.repository.get_all()\n\n    def get_todo_by_id(self, todo_id: str) -> Optional[Todo]:\n        \"\"\"Retrieve a specific todo item by ID.\"\"\"\n        return self.repository.get_by_id(todo_id)\n\n    def update_todo(self, todo_id: str, todo_data: TodoUpdate) -> Optional[Todo]:\n        \"\"\"Update an existing todo item.\"\"\"\n        existing_todo = self.repository.get_by_id(todo_id)\n        if not existing_todo:\n            return None\n        \n        update_data = todo_data.model_dump(exclude_unset=True)\n        \n        if \"title\" in update_data and update_data[\"title\"]:\n            update_data[\"title\"] = update_data[\"title\"].strip()\n        \n        return self.repository.update(todo_id, update_data)\n\n    def delete_todo(self, todo_id: str) -> bool:\n        \"\"\"Delete a todo item by ID.\"\"\"\n        return self.repository.delete(todo_id)"}, {"path": "app/api/v1/endpoints/todos.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom typing import List\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.database import get_session\nfrom app.schemas import TodoCreate, TodoUpdate, TodoResponse\nfrom app.services.todo_service import TodoService\n\nrouter = APIRouter(prefix=\"/todos\", tags=[\"todos\"])\n\n\ndef get_todo_service(session: AsyncSession = Depends(get_session)) -> TodoService:\n    return TodoService(session)\n\n\n@router.post(\"/\", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo_data: TodoCreate,\n    service: TodoService = Depends(get_todo_service)\n):\n    \"\"\"Create a new todo item.\"\"\"\n    todo = await service.create_todo(todo_data)\n    return todo\n\n\n@router.get(\"/\", response_model=List[TodoResponse])\nasync def list_todos(\n    service: TodoService = Depends(get_todo_service)\n):\n    \"\"\"Retrieve a list of all todo items.\"\"\"\n    todos = await service.get_all_todos()\n    return todos\n\n\n@router.get(\"/{todo_id}\", response_model=TodoResponse)\nasync def get_todo(\n    todo_id: str,\n    service: TodoService = Depends(get_todo_service)\n):\n    \"\"\"Retrieve a specific todo item by ID.\"\"\"\n    todo = await service.get_todo_by_id(todo_id)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return todo\n\n\n@router.put(\"/{todo_id}\", response_model=TodoResponse)\nasync def update_todo(\n    todo_id: str,\n    todo_data: TodoUpdate,\n    service: TodoService = Depends(get_todo_service)\n):\n    \"\"\"Update an existing todo item by ID.\"\"\"\n    todo = await service.update_todo(todo_id, todo_data)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return todo\n\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: str,\n    service: TodoService = Depends(get_todo_service)\n):\n    \"\"\"Delete a todo item by ID.\"\"\"\n    deleted = await service.delete_todo(todo_id)\n    if not deleted:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return None"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.database import get_session\nfrom app.schemas import TodoCreate, TodoUpdate, TodoResponse\nfrom app.services.todo_service import TodoService\n\nrouter = APIRouter()\n\n\n@router.post(\"/todos\", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo_data: TodoCreate,\n    session: AsyncSession = Depends(get_session)\n):\n    service = TodoService(session)\n    todo = await service.create_todo(todo_data)\n    return todo\n\n\n@router.get(\"/todos\", response_model=list[TodoResponse])\nasync def get_todos(\n    session: AsyncSession = Depends(get_session)\n):\n    service = TodoService(session)\n    todos = await service.get_todos()\n    return todos\n\n\n@router.get(\"/todos/{todo_id}\", response_model=TodoResponse)\nasync def get_todo(\n    todo_id: str,\n    session: AsyncSession = Depends(get_session)\n):\n    service = TodoService(session)\n    todo = await service.get_todo_by_id(todo_id)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return todo\n\n\n@router.put(\"/todos/{todo_id}\", response_model=TodoResponse)\nasync def update_todo(\n    todo_id: str,\n    todo_data: TodoUpdate,\n    session: AsyncSession = Depends(get_session)\n):\n    service = TodoService(session)\n    todo = await service.update_todo(todo_id, todo_data)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return todo\n\n\n@router.delete(\"/todos/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: str,\n    session: AsyncSession = Depends(get_session)\n):\n    service = TodoService(session)\n    deleted = await service.delete_todo(todo_id)\n    if not deleted:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Todo with id {todo_id} not found\"\n        )\n    return None\n</path>app/routes.py</path>"}, {"path": "app/auth.py", "content": "from datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\n# Configuration\nSECRET_KEY = \"your-secret-key-here-replace-in-production\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Password hashing context\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\n# Pydantic models for auth\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\nclass User(BaseModel):\n    username: str\n    email: Optional[str] = None\n    full_name: Optional[str] = None\n    disabled: Optional[bool] = None\n\n\nclass UserInDB(User):\n    hashed_password: str\n\n\n# Password utilities\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a plain password against a hashed password.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Generate password hash.\"\"\"\n    return pwd_context.hash(password)\n\n\n# Token utilities\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\n# Auth dependency\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> User:\n    \"\"\"Dependency to get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    \n    # In a real application, you would fetch the user from the database\n    # For this minimal implementation, we return a dummy user\n    user = User(username=token_data.username)\n    return user\n\n\n# Mock user database for demonstration\nfake_users_db = {\n    \"testuser\": {\n        \"username\": \"testuser\",\n        \"full_name\": \"Test User\",\n        \"email\": \"testuser@example.com\",\n        \"hashed_password\": get_password_hash(\"testpassword\"),\n        \"disabled\": False,\n    }\n}\n\n\ndef authenticate_user(username: str, password: str) -> Optional[UserInDB]:\n    \"\"\"Authenticate user with username and password.\"\"\"\n    if username not in fake_users_db:\n        return None\n    user_dict = fake_users_db[username]\n    hashed_password = user_dict[\"hashed_password\"]\n    if not verify_password(password, hashed_password):\n        return None\n    return UserInDB(**user_dict)"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}