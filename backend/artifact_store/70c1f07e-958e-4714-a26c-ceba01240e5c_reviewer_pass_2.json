{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app import routes\n\napp = FastAPI(\n    title=\"Calculator API\",\n    description=\"A simple API for basic arithmetic operations.\",\n    version=\"1.0.0\",\n)\n\napp.include_router(routes.router)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Welcome to the Calculator API. Use /add, /subtract, /multiply, or /divide.\"}"}, {"path": "app/routes.py", "content": "from typing import Annotated\n\nfrom fastapi import APIRouter, HTTPException, Query\nfrom app.services import CalculatorService\nfrom app.schemas import CalculationResult\n\nrouter = APIRouter()\n\n@router.get(\"/add\", response_model=CalculationResult)\nasync def add_numbers(\n    num1: Annotated[float, Query(description=\"First number\")],\n    num2: Annotated[float, Query(description=\"Second number\")],\n):\n    result = CalculatorService.add(num1, num2)\n    return CalculationResult(result=result)\n\n@router.get(\"/subtract\", response_model=CalculationResult)\nasync def subtract_numbers(\n    num1: Annotated[float, Query(description=\"First number\")],\n    num2: Annotated[float, Query(description=\"Second number\")],\n):\n    result = CalculatorService.subtract(num1, num2)\n    return CalculationResult(result=result)\n\n@router.get(\"/multiply\", response_model=CalculationResult)\nasync def multiply_numbers(\n    num1: Annotated[float, Query(description=\"First number\")],\n    num2: Annotated[float, Query(description=\"Second number\")],\n):\n    result = CalculatorService.multiply(num1, num2)\n    return CalculationResult(result=result)\n\n@router.get(\"/divide\", response_model=CalculationResult)\nasync def divide_numbers(\n    num1: Annotated[float, Query(description=\"First number\")],\n    num2: Annotated[float, Query(description=\"Second number\")],\n):\n    try:\n        result = CalculatorService.divide(num1, num2)\n        return CalculationResult(result=result)\n    except ZeroDivisionError:\n        raise HTTPException(status_code=400, detail=\"Cannot divide by zero\")"}, {"path": "app/services.py", "content": "from typing import Union\n\nclass CalculatorService:\n    @staticmethod\n    def add(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]:\n        return num1 + num2\n\n    @staticmethod\n    def subtract(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]:\n        return num1 - num2\n\n    @staticmethod\n    def multiply(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]:\n        return num1 * num2\n\n    @staticmethod\n    def divide(num1: Union[int, float], num2: Union[int, float]) -> Union[int, float]:\n        if num2 == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        return num1 / num2"}, {"path": "app/schemas.py", "content": "from pydantic import BaseModel, Field\n\nclass CalculationResult(BaseModel):\n    result: float = Field(..., description=\"The result of the arithmetic operation.\")\n\nclass ErrorResponse(BaseModel):\n    detail: str = Field(..., description=\"A description of the error that occurred.\")"}, {"path": "app/database.py", "content": "from typing import Generator\n\nfrom sqlmodel import Session, SQLModel, create_engine\n\nsqlite_file_name = \"database.db\"\nsqlite_url = f\"sqlite:///{sqlite_file_name}\"\n\nengine = create_engine(sqlite_url, echo=True)\n\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session"}, {"path": "app/models.py", "content": "from typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Item(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str = Field(index=True)\n    description: Optional[str] = Field(default=None, index=True)\n    price: float\n    tax: Optional[float] = None\n\n\nclass User(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    username: str = Field(index=True, unique=True)\n    hashed_password: str\n    is_active: bool = Field(default=True)"}, {"path": "app/auth.py", "content": "import os\nfrom typing import Annotated\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\nfrom app.database import get_session\nfrom sqlmodel import Session, select\nfrom app.models import User  # Import the actual User model\n\n# Configuration\nSECRET_KEY = os.environ[\"SECRET_KEY\"]  # Use environment variable, no default\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: str | None = None\n\n\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(\n    token: Annotated[str, Depends(oauth2_scheme)], session: Annotated[Session, Depends(get_session)]\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n\n    user = session.exec(select(User).where(User.username == token_data.username)).first()\n\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_active_user(\n    current_user: Annotated[User, Depends(get_current_user)]\n):\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user"}], "dependencies": ["fastapi", "uvicorn", "sqlmodel", "python-jose[cryptography]", "passlib[bcrypt]"]}