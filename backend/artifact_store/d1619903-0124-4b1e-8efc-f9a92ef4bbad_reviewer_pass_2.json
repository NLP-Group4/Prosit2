{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom sqlmodel import SQLModel\nfrom app.database import engine\nfrom app.routes import router as todo_router\n\napp = FastAPI(title=\"Todo Application API\")\n\n# Create tables\n@app.on_event(\"startup\")\ndef on_startup():\n    SQLModel.metadata.create_all(engine)\n\n# Include routes\napp.include_router(todo_router, prefix=\"/todos\", tags=[\"todos\"])"}, {"path": "app/database.py", "content": "from sqlmodel import create_engine, Session\nfrom typing import Generator\nimport os\n\n# Use SQLite for simplicity as per typical FastAPI examples.\n# For production, you'd use a proper DB like PostgreSQL.\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./test.db\")\n\n# Create the engine. For SQLite, check_same_thread is often needed.\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency that provides a database session for each request.\n    \"\"\"\n    with Session(engine) as session:\n        yield session"}, {"path": "app/models.py", "content": "from sqlmodel import SQLModel, Field\nfrom typing import Optional\nfrom datetime import datetime, timezone\n\nclass Todo(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), nullable=False)\n    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), nullable=False)"}, {"path": "app/schemas.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel\n\nclass TodoBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(TodoBase):\n    title: Optional[str] = None\n    completed: Optional[bool] = None\n\nclass TodoResponse(TodoBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        orm_mode = True\n\nclass TodoRead(TodoResponse):\n    pass"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlmodel import Session, select\nfrom typing import List\nfrom datetime import datetime, timezone\n\nfrom app.database import get_session\nfrom app.models import Todo\nfrom app.schemas import TodoCreate, TodoUpdate, TodoRead\n\nrouter = APIRouter(prefix=\"/todos\", tags=[\"todos\"])\n\n@router.post(\"/\", response_model=TodoRead, status_code=status.HTTP_201_CREATED)\ndef create_todo(todo_create: TodoCreate, session: Session = Depends(get_session)):\n    # Business rule: default completed status is false (handled by model)\n    todo = Todo(**todo_create.dict())\n    todo.created_at = datetime.now(timezone.utc)\n    todo.updated_at = datetime.now(timezone.utc)\n    session.add(todo)\n    session.commit()\n    session.refresh(todo)\n    return todo\n\n@router.get(\"/\", response_model=List[TodoRead])\ndef read_todos(session: Session = Depends(get_session)):\n    statement = select(Todo)\n    todos = session.exec(statement).all()\n    return todos\n\n@router.get(\"/{todo_id}\", response_model=TodoRead)\ndef read_todo(todo_id: int, session: Session = Depends(get_session)):\n    todo = session.get(Todo, todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.put(\"/{todo_id}\", response_model=TodoRead)\ndef update_todo(todo_id: int, todo_update: TodoUpdate, session: Session = Depends(get_session)):\n    db_todo = session.get(Todo, todo_id)\n    if not db_todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    \n    # Update only provided fields\n    update_data = todo_update.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(db_todo, key, value)\n    \n    db_todo.updated_at = datetime.now(timezone.utc)\n    session.add(db_todo)\n    session.commit()\n    session.refresh(db_todo)\n    return db_todo\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_todo(todo_id: int, session: Session = Depends(get_session)):\n    todo = session.get(Todo, todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    \n    session.delete(todo)\n    session.commit()\n    return"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nimport os\n\n# Secret key for JWT token encoding/decoding\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\nif SECRET_KEY is None:\n    raise ValueError(\"SECRET_KEY environment variable is not set. Please configure it for secure token operations.\")\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Password hashing context\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme for token extraction from request headers\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Dummy user storage for demonstration purposes\n# In a real application, this would be replaced by a database lookup\ndummy_users = {\n    \"user@example.com\": {\n        \"email\": \"user@example.com\",\n        \"hashed_password\": \"$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj/RK.PZvO.S\",  # \"password\"\n    }\n}\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a plain password against a hashed password.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_user(email: str) -> Optional[dict]:\n    \"\"\"Retrieve a user by email from the dummy user storage.\"\"\"\n    return dummy_users.get(email)\n\ndef authenticate_user(email: str, password: str) -> Optional[dict]:\n    \"\"\"Authenticate a user by verifying their credentials.\"\"\"\n    user = get_user(email)\n    if not user:\n        return None\n    if not verify_password(password, user[\"hashed_password\"]):\n        return None\n    return user\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token with an optional expiration time.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:\n    \"\"\"Dependency to retrieve and validate the current authenticated user from a JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = get_user(email)\n    if user is None:\n        raise credentials_exception\n    return user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}