{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nimport logging\n\nfrom app.routes import router as api_router\nfrom app.database import init_db\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"app.main\")\n\napp = FastAPI(title=\"Minimal Calculator API\", version=\"0.1.0\")\n\napp.include_router(api_router)\n\n\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    logger.info(\"Starting up application and initializing database...\")\n    init_db()\n    logger.info(\"Database initialization complete.\")"}, {"path": "app/database.py", "content": "import os\nimport logging\nfrom typing import Generator, Optional\n\nfrom sqlmodel import SQLModel, create_engine, Session\nfrom sqlalchemy.orm import sessionmaker\n\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./calculations.db\")\n\n# SQLite needs this flag to allow usage from multiple threads\nconnect_args: Optional[dict] = {\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else None\n\n# create_engine accepts connect_args only when not None\n_engine = create_engine(DATABASE_URL, echo=False, connect_args=connect_args)  # type: ignore[arg-type]\n\n# Session factory using SQLModel's Session class\nSessionLocal = sessionmaker(bind=_engine, class_=Session, expire_on_commit=False)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency for FastAPI routes. Yields a SQLModel Session and ensures it is closed after use.\n    Usage:\n        def endpoint(session: Session = Depends(get_session)):\n            ...\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\ndef init_db() -> None:\n    \"\"\"\n    Create database tables for all SQLModel models.\n    Call this at application startup to ensure tables exist.\n    \"\"\"\n    logger.info(\"Initializing database and creating tables (if not present).\")\n    SQLModel.metadata.create_all(_engine)\n\n\n# Expose engine for other modules if needed\nengine = _engine"}, {"path": "app/models.py", "content": "from typing import Optional\nfrom datetime import datetime\nfrom sqlmodel import SQLModel, Field\n\n\nclass Calculation(SQLModel, table=True):\n    \"\"\"\n    Calculation table mapping.\n\n    Fields:\n    - id: primary key, auto-increment\n    - operand1: first operand (float)\n    - operand2: second operand (float)\n    - operation: operation name ('add', 'sub', 'mul', 'div')\n    - result: result of the calculation, null if error occurred\n    - error: error message if any, null otherwise\n    - created_at: timestamp of creation (UTC)\n    \"\"\"\n    __tablename__ = \"calculations\"\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    operand1: float\n    operand2: float\n    operation: str = Field(index=True, description=\"Operation: add|sub|mul|div\")\n    result: Optional[float] = None\n    error: Optional[str] = None\n    created_at: datetime = Field(default_factory=lambda: datetime.utcnow())"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom datetime import datetime\nfrom sqlmodel import SQLModel, Field\nfrom pydantic import validator, BaseModel\n\n\n_OPERATION_ALIASES = {\n    \"+\": \"add\",\n    \"-\": \"sub\",\n    \"*\": \"mul\",\n    \"/\": \"div\",\n}\n_VALID_OPERATIONS = {\"add\", \"sub\", \"mul\", \"div\"}\n\n\nclass CalculateRequest(SQLModel):\n    operand1: float\n    operand2: float\n    operation: str\n\n    @validator(\"operation\", pre=True)\n    def normalize_operation(cls, v: str) -> str:\n        if not isinstance(v, str):\n            raise ValueError(\"operation must be a string\")\n        token = v.strip().lower()\n        # Map operator symbols to names\n        if token in _OPERATION_ALIASES:\n            token = _OPERATION_ALIASES[token]\n        if token not in _VALID_OPERATIONS:\n            raise ValueError(f\"unsupported operation '{v}'\")\n        return token\n\n    class Config:\n        anystr_strip_whitespace = True\n        schema_extra = {\n            \"example\": {\"operand1\": 2.0, \"operand2\": 3.0, \"operation\": \"add\"}\n        }\n\n\nclass CalculationRead(SQLModel):\n    id: int\n    operand1: float\n    operand2: float\n    operation: str\n    result: Optional[float] = None\n    error: Optional[str] = None\n    created_at: datetime = Field(..., description=\"ISO8601 timestamp\")\n\n    class Config:\n        orm_mode = True\n        schema_extra = {\n            \"example\": {\n                \"id\": 1,\n                \"operand1\": 2.0,\n                \"operand2\": 3.0,\n                \"operation\": \"add\",\n                \"result\": 5.0,\n                \"error\": None,\n                \"created_at\": \"2026-02-27T12:34:56Z\",\n            }\n        }\n\n\nclass ErrorResponse(BaseModel):\n    error: str\n    code: str\n\n    class Config:\n        schema_extra = {\"example\": {\"error\": \"Division by zero\", \"code\": \"DivisionByZero\"}}"}, {"path": "app/routes.py", "content": "from typing import List\nfrom datetime import datetime, timezone\nimport math\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\n\nfrom app.database import get_session\nfrom app.models import Calculation\nfrom app.schemas import CalculateRequest, CalculationResponse\nfrom app.core import (\n    calculate,\n    InvalidInputError,\n    DivisionByZeroError,\n    CalculationError,\n)\nfrom app import repository\nfrom app.auth import get_current_user\n\nrouter = APIRouter()\n\n# Allowed canonical operations\n_ALLOWED_OPERATIONS = {\"add\", \"sub\", \"mul\", \"div\"}\n# Common CLI/operator aliases mapped to canonical operations\n_OPERATION_ALIASES = {\n    \"+\": \"add\",\n    \"-\": \"sub\",\n    \"*\": \"mul\",\n    \"/\": \"div\",\n}\n\n\n@router.post(\"/calculate\", response_model=CalculationResponse, status_code=200, tags=[\"calculate\"])\nasync def post_calculate(\n    payload: CalculateRequest, session=Depends(get_session)\n) -> Calculation:\n    \"\"\"\n    Perform a calculation, store the result (or error) and return the stored record.\n    Inputs are validated and normalized before being passed to core logic and repository\n    to avoid any possibility of using unsanitized user input in SQL queries.\n    Domain errors like invalid input or division by zero return structured 400 responses.\n    \"\"\"\n    # Validate numeric operands (ensure finite floats)\n    op1 = payload.operand1\n    op2 = payload.operand2\n\n    if not isinstance(op1, (int, float)) or not math.isfinite(float(op1)):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"operand1 must be a finite number\", \"code\": \"InvalidInput\"},\n        )\n    if not isinstance(op2, (int, float)) or not math.isfinite(float(op2)):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"operand2 must be a finite number\", \"code\": \"InvalidInput\"},\n        )\n\n    # Normalize and validate operation (map aliases and enforce canonical set)\n    raw_op = (payload.operation or \"\").strip().lower()\n    op = _OPERATION_ALIASES.get(raw_op, raw_op)\n    if op not in _ALLOWED_OPERATIONS:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": f\"unsupported operation '{payload.operation}'\", \"code\": \"InvalidInput\"},\n        )\n\n    # Call core calculation with validated/sanitized inputs\n    try:\n        result, error = calculate(float(op1), float(op2), op)\n    except InvalidInputError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": str(exc), \"code\": \"InvalidInput\"},\n        )\n    except DivisionByZeroError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": str(exc), \"code\": \"DivisionByZero\"},\n        )\n    except CalculationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail={\"error\": str(exc), \"code\": \"CalculationError\"},\n        )\n\n    # If core returned a domain error in tuple form, surface it as 400\n    if error is not None:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": error, \"code\": \"InvalidInput\"},\n        )\n\n    # Build calculation record using sanitized operation\n    calc = Calculation(\n        operand1=float(op1),\n        operand2=float(op2),\n        operation=op,\n        result=result,\n        error=None,\n        created_at=datetime.now(timezone.utc),\n    )\n\n    created = repository.create_calculation(session, calc)\n    return created\n\n\n@router.get(\n    \"/calculations\",\n    response_model=List[CalculationResponse],\n    status_code=200,\n    tags=[\"calculations\"],\n)\nasync def list_calculations(\n    limit: int = 100,\n    offset: int = 0,\n    session=Depends(get_session),\n    current_user=Depends(get_current_user),\n) -> List[Calculation]:\n    \"\"\"\n    List stored calculations. Protected endpoint (requires authentication).\n    Supports pagination via limit and offset. Inputs are clamped to safe ranges.\n    \"\"\"\n    try:\n        limit = int(limit)\n    except Exception:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"limit must be an integer\", \"code\": \"InvalidInput\"},\n        )\n    try:\n        offset = int(offset)\n    except Exception:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"offset must be an integer\", \"code\": \"InvalidInput\"},\n        )\n\n    limit = max(1, min(1000, limit))\n    offset = max(0, offset)\n    items = repository.list_calculations(session, limit=limit, offset=offset)\n    return items\n\n\n@router.get(\n    \"/calculations/{calc_id}\",\n    response_model=CalculationResponse,\n    status_code=200,\n    tags=[\"calculations\"],\n)\nasync def get_calculation(\n    calc_id: int,\n    session=Depends(get_session),\n    current_user=Depends(get_current_user),\n) -> Calculation:\n    \"\"\"\n    Retrieve a single calculation by id. Protected endpoint.\n    Validate calc_id to ensure it's a positive integer before using it in queries.\n    \"\"\"\n    try:\n        calc_id = int(calc_id)\n    except Exception:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"calc_id must be an integer\", \"code\": \"InvalidInput\"},\n        )\n\n    if calc_id <= 0:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": \"calc_id must be a positive integer\", \"code\": \"InvalidInput\"},\n        )\n\n    item = repository.get_calculation(session, calc_id)\n    if item is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail={\"error\": \"Calculation not found\", \"code\": \"NotFound\"},\n        )\n    return item"}, {"path": "app/core.py", "content": "from typing import Optional, Tuple, Dict\nimport numbers\n\n\nclass CalculationError(Exception):\n    \"\"\"\n    Base class for calculation domain errors.\n    Attributes:\n        message: human readable message\n        code: machine-friendly error code\n    \"\"\"\n    code: str = \"CalculationError\"\n\n    def __init__(self, message: str):\n        super().__init__(message)\n        self.message = message\n\n\nclass InvalidInputError(CalculationError):\n    code = \"InvalidInput\"\n\n    def __init__(self, message: str = \"Invalid input\"):\n        super().__init__(message)\n\n\nclass DivisionByZeroError(CalculationError):\n    code = \"DivisionByZero\"\n\n    def __init__(self, message: str = \"Division by zero\"):\n        super().__init__(message)\n\n\n# Supported operations mapping: accepts canonical names and common operator aliases.\n_OPERATION_ALIASES = {\n    \"add\": \"add\",\n    \"+\": \"add\",\n    \"plus\": \"add\",\n    \"sub\": \"sub\",\n    \"subtract\": \"sub\",\n    \"-\": \"sub\",\n    \"minus\": \"sub\",\n    \"mul\": \"mul\",\n    \"multiply\": \"mul\",\n    \"*\": \"mul\",\n    \"times\": \"mul\",\n    \"div\": \"div\",\n    \"divide\": \"div\",\n    \"/\": \"div\",\n}\n\n\ndef _normalize_operation(operation: str) -> str:\n    if not isinstance(operation, str):\n        raise InvalidInputError(\"Operation must be a string\")\n    key = operation.strip().lower()\n    if key not in _OPERATION_ALIASES:\n        raise InvalidInputError(f\"Unsupported operation: {operation}\")\n    return _OPERATION_ALIASES[key]\n\n\ndef _validate_operand(value, name: str) -> float:\n    # Accept ints and floats (numbers.Real), reject NaN/Inf\n    if not isinstance(value, numbers.Real):\n        raise InvalidInputError(f\"{name} must be a number\")\n    # numbers.Real includes bool, exclude bool explicitly\n    if isinstance(value, bool):\n        raise InvalidInputError(f\"{name} must be a number\")\n    val = float(value)\n    if val != val:  # NaN check\n        raise InvalidInputError(f\"{name} must be a finite number\")\n    if val in (float(\"inf\"), float(\"-inf\")):\n        raise InvalidInputError(f\"{name} must be a finite number\")\n    return val\n\n\ndef calculate(operand1: float, operand2: float, operation: str) -> float:\n    \"\"\"\n    Perform a calculation.\n\n    Args:\n        operand1: left operand (number).\n        operand2: right operand (number).\n        operation: operation name or alias (e.g., \"add\", \"+\", \"DIV\", \"/\").\n\n    Returns:\n        result as float\n\n    Raises:\n        InvalidInputError: if inputs are invalid or operation unsupported.\n        DivisionByZeroError: if dividing by zero.\n        CalculationError: for other calculation-related errors.\n    \"\"\"\n    a = _validate_operand(operand1, \"operand1\")\n    b = _validate_operand(operand2, \"operand2\")\n    op = _normalize_operation(operation)\n\n    try:\n        if op == \"add\":\n            return a + b\n        elif op == \"sub\":\n            return a - b\n        elif op == \"mul\":\n            return a * b\n        elif op == \"div\":\n            if b == 0.0:\n                raise DivisionByZeroError(\"Division by zero\")\n            return a / b\n        else:\n            # Defensive; should not happen due to normalization\n            raise InvalidInputError(f\"Unsupported operation: {operation}\")\n    except CalculationError:\n        # Re-raise domain errors unchanged\n        raise\n    except Exception as exc:\n        # Wrap unexpected errors\n        raise CalculationError(f\"Internal calculation error: {exc}\") from exc\n\n\ndef calculate_safe(operand1: float, operand2: float, operation: str) -> Tuple[Optional[float], Optional[Dict[str, str]]]:\n    \"\"\"\n    Safe wrapper around calculate that returns a (result, error) tuple instead\n    of raising. The error, if present, is a dict with keys 'code' and 'message'.\n\n    Returns:\n        (result, None) on success\n        (None, {\"code\": ..., \"message\": ...}) on known domain errors\n        (None, {\"code\": \"CalculationError\", \"message\": \"...\"}) on unexpected errors\n    \"\"\"\n    try:\n        result = calculate(operand1, operand2, operation)\n        return result, None\n    except CalculationError as ce:\n        return None, {\"code\": getattr(ce, \"code\", \"CalculationError\"), \"message\": ce.message}\n    except Exception as exc:\n        return None, {\"code\": \"CalculationError\", \"message\": str(exc)}"}, {"path": "app/repository.py", "content": "import threading\nfrom typing import List, Optional\n\nfrom sqlmodel import Session, select\n\nfrom app.models import Calculation\n\n\nclass CalculationRepository:\n    \"\"\"\n    Repository for Calculation records using SQLModel sessions.\n\n    All public methods acquire an internal threading.Lock to ensure thread-safety\n    when used from a multi-threaded environment (e.g., FastAPI).\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n\n    def create(self, session: Session, calc: Calculation) -> Calculation:\n        \"\"\"\n        Persist a Calculation instance and return the stored model (with id and defaults populated).\n        \"\"\"\n        with self._lock:\n            session.add(calc)\n            session.commit()\n            session.refresh(calc)\n            return calc\n\n    def list(self, session: Session, limit: int = 100, offset: int = 0) -> List[Calculation]:\n        \"\"\"\n        Return a list of Calculation records with pagination.\n        \"\"\"\n        with self._lock:\n            statement = select(Calculation).offset(offset).limit(limit).order_by(Calculation.id)\n            results = session.exec(statement).all()\n            return results\n\n    def get(self, session: Session, id: int) -> Optional[Calculation]:\n        \"\"\"\n        Retrieve a single Calculation by id or return None if not found.\n        \"\"\"\n        with self._lock:\n            statement = select(Calculation).where(Calculation.id == id)\n            result = session.exec(statement).first()\n            return result\n\n\n# convenience single repository instance\nrepository = CalculationRepository()"}, {"path": "app/auth.py", "content": "import os\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\n# NOTE: Secrets must be provided securely. Prefer a secrets manager (AWS Secrets Manager, GCP Secret Manager, HashiCorp Vault, etc.)\n# This module validates that a sufficiently strong SECRET_KEY is present in the environment before application startup.\n\ndef _is_valid_secret_key(value: Optional[str]) -> bool:\n    if not value or not isinstance(value, str):\n        return False\n    # Basic checks: length and not a common placeholder string.\n    if len(value) < 32:\n        return False\n    lowered = value.strip().lower()\n    if lowered in {\"\", \"secret\", \"changeme\", \"change-me\", \"default\", \"password\", \"pass\"}:\n        return False\n    return True\n\n\n# Secret key - require it from environment for safety and validate strength.\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\nif not SECRET_KEY:\n    raise RuntimeError(\n        \"SECRET_KEY environment variable must be set. \"\n        \"Provide a secure random key (at least 32 characters). \"\n        \"For production, store secrets in a secrets manager rather than environment variables.\"\n    )\nif not _is_valid_secret_key(SECRET_KEY):\n    raise RuntimeError(\n        \"SECRET_KEY is present but does not meet basic strength requirements (min length 32 and not a placeholder). \"\n        \"Provide a secure random key. Consider using a managed secrets service to supply this value.\"\n    )\n\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60\n\n# OAuth2 scheme. tokenUrl should match the actual token route used by the application.\n# The application should provide a POST /token route that exchanges username/password for a token.\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\n# Minimal in-memory user \"database\"\n# Passwords should not be hardcoded. Load from environment or a secrets manager if needed.\ndef _hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\n\n# Prefer providing a pre-hashed password via ALICE_PASSWORD_HASH for security.\n# If ALICE_PASSWORD (raw password) is provided, it will be hashed at startup after basic validation.\n# If neither is provided, the demo user will be disabled until credentials are supplied.\nALICE_PASSWORD_HASH = os.getenv(\"ALICE_PASSWORD_HASH\")\nALICE_PASSWORD = os.getenv(\"ALICE_PASSWORD\")\n\nif ALICE_PASSWORD_HASH:\n    _alice_hashed = ALICE_PASSWORD_HASH\nelif ALICE_PASSWORD:\n    # Basic validation for provided raw password to avoid extremely weak defaults.\n    if not isinstance(ALICE_PASSWORD, str) or len(ALICE_PASSWORD) < 8:\n        raise RuntimeError(\n            \"ALICE_PASSWORD is provided but is too short. Use at least 8 characters or provide ALICE_PASSWORD_HASH. \"\n            \"For production, store user credentials in a secure secrets store and provide hashed passwords.\"\n        )\n    _alice_hashed = _hash_password(ALICE_PASSWORD)\nelse:\n    _alice_hashed = None\n\n_users_db: Dict[str, Dict[str, Any]] = {\n    \"alice\": {\n        \"username\": \"alice\",\n        \"full_name\": \"Alice Example\",\n        \"email\": \"alice@example.com\",\n        # Disable the demo account if no password was provided via environment.\n        \"disabled\": False if _alice_hashed else True,\n    }\n}\n\nif _alice_hashed:\n    _users_db[\"alice\"][\"hashed_password\"] = _alice_hashed\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_user(username: str) -> Optional[Dict[str, Any]]:\n    return _users_db.get(username)\n\n\ndef authenticate_user(username: str, password: str) -> Optional[Dict[str, Any]]:\n    user = get_user(username)\n    if not user:\n        return None\n    hashed = user.get(\"hashed_password\")\n    if not hashed:\n        # No password configured for this user; authentication not possible.\n        return None\n    if not verify_password(password, hashed):\n        return None\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    now = datetime.utcnow()\n    if expires_delta:\n        expire = now + expires_delta\n    else:\n        expire = now + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire, \"iat\": now})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> Dict[str, Any]:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: Optional[str] = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_active_user(current_user: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:\n    if current_user.get(\"disabled\"):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}