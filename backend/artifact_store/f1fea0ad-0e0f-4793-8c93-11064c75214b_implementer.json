{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.routers import tasks\n\napp = FastAPI()\n\napp.include_router(tasks.router, prefix=\"/tasks\", tags=[\"tasks\"])"}, {"path": "app/database.py", "content": "from typing import Generator\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlmodel import SQLModel\n\n# Database URL - adjust this for your environment\nDATABASE_URL = \"sqlite:///./todo.db\"\n\n# Create async engine\nengine = create_async_engine(DATABASE_URL, echo=True)\n\n# Create async session class\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\n# Sync engine for SQLModel metadata\nsync_engine = create_engine(DATABASE_URL, echo=True)\nSQLModel.metadata.create_all(sync_engine)\n\nasync def get_db() -> Generator[AsyncSession, None, None]:\n    \"\"\"Dependency to get a database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        yield session"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Task(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field\n\nclass TaskBase(BaseModel):\n    title: str = Field(..., min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n    completed: bool = False\n\nclass TaskCreate(TaskBase):\n    pass\n\nclass TaskUpdate(TaskBase):\n    title: Optional[str] = Field(None, min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n    completed: Optional[bool] = None\n\nclass Task(TaskBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.services import task_service\nfrom app.schemas import TaskCreate, TaskUpdate, TaskRead\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=list[TaskRead])\nasync def list_tasks(db: Session = Depends(get_session)):\n    return task_service.list_tasks(db)\n\n@router.post(\"/\", response_model=TaskRead)\nasync def create_task(task: TaskCreate, db: Session = Depends(get_session)):\n    return task_service.create_task(db, task)\n\n@router.get(\"/{task_id}\", response_model=TaskRead)\nasync def get_task(task_id: int, db: Session = Depends(get_session)):\n    task = task_service.get_task(db, task_id)\n    if task is None:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return task\n\n@router.put(\"/{task_id}\", response_model=TaskRead)\nasync def update_task(task_id: int, task: TaskUpdate, db: Session = Depends(get_session)):\n    updated_task = task_service.update_task(db, task_id, task)\n    if updated_task is None:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return updated_task\n\n@router.delete(\"/{task_id}\")\nasync def delete_task(task_id: int, db: Session = Depends(get_session)):\n    if not task_service.delete_task(db, task_id):\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return {\"message\": \"Task deleted successfully\"}"}, {"path": "app/services.py", "content": "from typing import List\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom app.models import Task\nfrom app.schemas import TaskCreate, TaskUpdate\nfrom app.repositories import TaskRepository\nfrom app.database import get_session\n\nclass TaskService:\n    def __init__(self, repository: TaskRepository):\n        self.repository = repository\n\n    def list_tasks(self) -> List[Task]:\n        return self.repository.list()\n\n    def create_task(self, task_data: TaskCreate) -> Task:\n        if not task_data.title:\n            raise ValueError(\"Task title cannot be empty\")\n        return self.repository.create(task_data)\n\n    def get_task(self, task_id: int) -> Task:\n        task = self.repository.get(task_id)\n        if task is None:\n            raise ValueError(f\"Task with id {task_id} not found\")\n        return task\n\n    def update_task(self, task_id: int, task_data: TaskUpdate) -> Task:\n        task = self.repository.get(task_id)\n        if task is None:\n            raise ValueError(f\"Task with id {task_id} not found\")\n        return self.repository.update(task_id, task_data)\n\n    def delete_task(self, task_id: int) -> None:\n        task = self.repository.get(task_id)\n        if task is None:\n            raise ValueError(f\"Task with id {task_id} not found\")\n        self.repository.delete(task_id)"}, {"path": "app/repositories.py", "content": "from typing import List, Optional\n\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.models import Task\n\n\nclass TaskRepository:\n    @staticmethod\n    async def list_tasks(db: AsyncSession) -> List[Task]:\n        result = await db.execute(select(Task))\n        return result.scalars().all()\n\n    @staticmethod\n    async def get_task(db: AsyncSession, task_id: int) -> Optional[Task]:\n        result = await db.execute(select(Task).where(Task.id == task_id))\n        return result.scalar_one_or_none()\n\n    @staticmethod\n    async def create_task(db: AsyncSession, task: Task) -> Task:\n        db.add(task)\n        await db.commit()\n        await db.refresh(task)\n        return task\n\n    @staticmethod\n    async def update_task(db: AsyncSession, task_id: int, task_data: Task) -> Optional[Task]:\n        task = await TaskRepository.get_task(db, task_id)\n        if not task:\n            return None\n\n        task.title = task_data.title\n        task.description = task_data.description\n        task.completed = task_data.completed\n        await db.commit()\n        await db.refresh(task)\n        return task\n\n    @staticmethod\n    async def delete_task(db: AsyncSession, task_id: int) -> bool:\n        result = await db.execute(delete(Task).where(Task.id == task_id))\n        await db.commit()\n        return result.rowcount > 0"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom app.config import settings\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# JWT token handling\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Token verification\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n\ndef verify_token(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    return username"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "pydantic", "python-jose[cryptography]", "passlib[bcrypt]"]}