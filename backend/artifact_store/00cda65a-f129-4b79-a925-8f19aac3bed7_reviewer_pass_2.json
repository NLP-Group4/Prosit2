{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom app.database import engine\nfrom app.models import Base\nfrom app.routes import todo_router\n\napp = FastAPI()\n\n# Create database tables\nBase.metadata.create_all(bind=engine)\n\n# Register routers\napp.include_router(todo_router, prefix=\"/todos\", tags=[\"todos\"])\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Todo API is running\"}"}, {"path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlmodel import SQLModel\nfrom app.config import settings\n\n# Create the database engine\nengine = create_async_engine(settings.DATABASE_URL, echo=True)\n\n# Create a session factory\nasync_session = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\n# Dependency to get a database session\nasync def get_session():\n    async with async_session() as session:\n        yield session\n\n# Create all tables in the database\nSQLModel.metadata.create_all(engine)"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import SQLModel, Field\n\n\nclass TodoBase(SQLModel):\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n\n\nclass TodoCreate(TodoBase):\n    pass\n\n\nclass TodoUpdate(SQLModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    completed: Optional[bool] = None\n\n\nclass Todo(TodoBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass TodoBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    completed: Optional[bool] = None\n\nclass Todo(TodoBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app import schemas, services\nfrom app.database import get_async_session\nfrom app.auth import verify_token\n\nrouter = APIRouter()\n\n@router.get(\"/todos\", response_model=list[schemas.Todo])\nasync def get_todos(session: AsyncSession = Depends(get_async_session), token: str = Depends(verify_token)):\n    return await services.get_todos(session)\n\n@router.post(\"/todos\", response_model=schemas.Todo, status_code=status.HTTP_201_CREATED)\nasync def create_todo(todo: schemas.TodoCreate, session: AsyncSession = Depends(get_async_session), token: str = Depends(verify_token)):\n    return await services.create_todo(session, todo)\n\n@router.get(\"/todos/{todo_id}\", response_model=schemas.Todo)\nasync def get_todo(todo_id: int, session: AsyncSession = Depends(get_async_session), token: str = Depends(verify_token)):\n    todo = await services.get_todo(session, todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.put(\"/todos/{todo_id}\", response_model=schemas.Todo)\nasync def update_todo(todo_id: int, todo: schemas.TodoUpdate, session: AsyncSession = Depends(get_async_session), token: str = Depends(verify_token)):\n    updated_todo = await services.update_todo(session, todo_id, todo)\n    if not updated_todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return updated_todo\n\n@router.delete(\"/todos/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(todo_id: int, session: AsyncSession = Depends(get_async_session), token: str = Depends(verify_token)):\n    if not await services.delete_todo(session, todo_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return None"}, {"path": "app/services.py", "content": "from typing import List, Optional\n\nfrom app.models import Todo\nfrom app.repositories import TodoRepository\nfrom app.schemas import TodoCreate, TodoUpdate\n\n\nclass TodoService:\n    def __init__(self, repository: TodoRepository):\n        self.repository = repository\n\n    def get_todo(self, todo_id: int) -> Optional[Todo]:\n        return self.repository.get(todo_id)\n\n    def get_todos(self) -> List[Todo]:\n        return self.repository.get_all()\n\n    def create_todo(self, todo_data: TodoCreate) -> Todo:\n        return self.repository.create(todo_data)\n\n    def update_todo(self, todo_id: int, todo_data: TodoUpdate) -> Optional[Todo]:\n        return self.repository.update(todo_id, todo_data)\n\n    def delete_todo(self, todo_id: int) -> bool:\n        return self.repository.delete(todo_id)"}, {"path": "app/repositories.py", "content": "from typing import List, Optional\nfrom sqlalchemy import select, update, delete\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.models import Todo\nfrom app.database import get_session\nfrom app.schemas import TodoUpdate\n\nclass TodoRepository:\n    @classmethod\n    async def get_all(cls, session: AsyncSession) -> List[Todo]:\n        result = await session.execute(select(Todo))\n        return result.scalars().all()\n\n    @classmethod\n    async def get_by_id(cls, session: AsyncSession, todo_id: int) -> Optional[Todo]:\n        result = await session.execute(select(Todo).where(Todo.id == todo_id))\n        return result.scalar_one_or_none()\n\n    @classmethod\n    async def create(cls, session: AsyncSession, todo: Todo) -> Todo:\n        session.add(todo)\n        await session.commit()\n        await session.refresh(todo)\n        return todo\n\n    @classmethod\n    async def update(cls, session: AsyncSession, todo_id: int, data: TodoUpdate) -> Optional[Todo]:\n        # Convert Pydantic model to dictionary for update\n        update_data = data.model_dump()\n        stmt = update(Todo).where(Todo.id == todo_id).values(**update_data)\n        await session.execute(stmt)\n        await session.commit()\n        return await cls.get_by_id(session, todo_id)\n\n    @classmethod\n    async def delete(cls, session: AsyncSession, todo_id: int) -> bool:\n        stmt = delete(Todo).where(Todo.id == todo_id)\n        result = await session.execute(stmt)\n        await session.commit()\n        return result.rowcount > 0"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom app.config import settings\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# JWT token settings\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\ndef verify_token(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    return username"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "pydantic", "sqlalchemy", "python-jose[cryptography]", "passlib[bcrypt]"]}