{"files": [{"path": "app/main.py", "content": "from contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom app.database import create_db_and_tables\nfrom app.routes import router as api_router\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"\n    Context manager to handle application startup and shutdown events.\n    On startup, it creates the database and tables.\n    \"\"\"\n    print(\"INFO:     Creating database and tables on startup.\")\n    create_db_and_tables()\n    yield\n    print(\"INFO:     Application shutting down.\")\n\n\napp = FastAPI(\n    title=\"Todo API\",\n    version=\"0.1.0\",\n    description=\"A simple API for managing tasks.\",\n    lifespan=lifespan,\n)\n\n# Include the main router from app/routes.py\napp.include_router(api_router)\n\n\n@app.get(\"/\", tags=[\"Root\"])\ndef read_root():\n    \"\"\"\n    A simple root endpoint to confirm the API is running.\n    \"\"\"\n    return {\"message\": \"Todo API is running\"}"}, {"path": "app/database.py", "content": "from sqlmodel import create_engine, Session, SQLModel\n\nDATABASE_URL = \"sqlite:///database.db\"\n\n# The connect_args is needed only for SQLite.\n# It's not needed for other databases.\nengine = create_engine(DATABASE_URL, echo=True, connect_args={\"check_same_thread\": False})\n\n\ndef create_db_and_tables():\n    \"\"\"\n    Creates the database and all tables defined by SQLModel metadata.\n    This function should be called on application startup.\n    \"\"\"\n    SQLModel.metadata.create_all(engine)\n\n\ndef get_session():\n    \"\"\"\n    FastAPI dependency to get a database session.\n    Yields a session and ensures it's closed after the request is handled.\n    \"\"\"\n    with Session(engine) as session:\n        yield session"}, {"path": "app/models.py", "content": "import uuid\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Task(SQLModel, table=True):\n    id: Optional[uuid.UUID] = Field(\n        default_factory=uuid.uuid4,\n        primary_key=True,\n        index=True,\n        nullable=False,\n    )\n    title: str = Field(index=True, unique=True)\n    description: Optional[str] = Field(default=None)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom sqlmodel import SQLModel\nfrom uuid import UUID\nfrom datetime import datetime\n\n\nclass TaskCreate(SQLModel):\n    title: str\n    description: Optional[str] = None\n\n\nclass TaskUpdate(SQLModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    completed: Optional[bool] = None\n\n\nclass TaskRead(SQLModel):\n    id: UUID\n    title: str\n    description: Optional[str] = None\n    completed: bool\n    created_at: datetime"}, {"path": "app/routes.py", "content": "from typing import List\nimport uuid\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlmodel import Session, select\n\nfrom app.database import get_session\nfrom app.models import Task\nfrom app.schemas import TaskCreate, TaskRead, TaskUpdate\n\nrouter = APIRouter()\n\n\n@router.post(\"/tasks\", response_model=TaskRead, status_code=status.HTTP_201_CREATED)\ndef create_task(*, session: Session = Depends(get_session), task_in: TaskCreate):\n    \"\"\"\n    Create a new task.\n    \"\"\"\n    # Check if a task with the same title already exists\n    existing_task = session.exec(select(Task).where(Task.title == task_in.title)).first()\n    if existing_task:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"A task with this title already exists.\",\n        )\n\n    db_task = Task.model_validate(task_in)\n    session.add(db_task)\n    session.commit()\n    session.refresh(db_task)\n    return db_task\n\n\n@router.get(\"/tasks\", response_model=List[TaskRead])\ndef read_tasks(*, session: Session = Depends(get_session)):\n    \"\"\"\n    Retrieve all tasks.\n    \"\"\"\n    tasks = session.exec(select(Task)).all()\n    return tasks\n\n\n@router.get(\"/tasks/{task_id}\", response_model=TaskRead)\ndef read_task(*, session: Session = Depends(get_session), task_id: uuid.UUID):\n    \"\"\"\n    Retrieve a single task by its ID.\n    \"\"\"\n    task = session.get(Task, task_id)\n    if not task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return task\n\n\n@router.put(\"/tasks/{task_id}\", response_model=TaskRead)\ndef update_task(*, session: Session = Depends(get_session), task_id: uuid.UUID, task_in: TaskUpdate):\n    \"\"\"\n    Update an existing task.\n    \"\"\"\n    db_task = session.get(Task, task_id)\n    if not db_task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n\n    # Check if the new title is already taken by another task\n    if task_in.title and task_in.title != db_task.title:\n        existing_task = session.exec(select(Task).where(Task.title == task_in.title)).first()\n        if existing_task and existing_task.id != task_id:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"A task with this title already exists.\",\n            )\n\n    task_data = task_in.model_dump(exclude_unset=True)\n    for key, value in task_data.items():\n        setattr(db_task, key, value)\n\n    session.add(db_task)\n    session.commit()\n    session.refresh(db_task)\n    return db_task\n\n\n@router.delete(\"/tasks/{task_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(*, session: Session = Depends(get_session), task_id: uuid.UUID):\n    \"\"\"\n    Delete a task by its ID.\n    \"\"\"\n    task = session.get(Task, task_id)\n    if not task:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n\n    session.delete(task)\n    session.commit()\n    return"}, {"path": "app/auth.py", "content": "import os\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\n# --- Security Configuration ---\n# It is critical to use a strong, secret key for JWT signing.\n# This must be loaded from environment variables and never hardcoded.\n# The application will fail to start if this environment variable is not set.\n# Generate a key with: openssl rand -hex 32\nSECRET_KEY = os.environ[\"SECRET_KEY\"]\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# This expects a form post to `/token` with `username` and `password`\n# The `tokenUrl` should match the path of the token-issuing endpoint.\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verifies a plain password against a hashed one.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hashes a password using bcrypt.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"\n    Creates a new access token.\n    :param data: The data to be encoded in the token (e.g., {'sub': username}).\n    :param expires_delta: Optional timedelta for token expiration.\n    :return: The encoded JWT token as a string.\n    \"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> str:\n    \"\"\"\n    Decodes the JWT token to get the current user.\n    Raises HTTPException if the token is invalid or expired.\n    In a real app, this would typically return a user object from the database.\n    For this project, it will just return the username (subject) from the token.\n    \"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: Optional[str] = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n\n    # In a full application, you would load the user from the database here\n    # and return the user object. For this minimal example, we just return the username.\n    return username"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}