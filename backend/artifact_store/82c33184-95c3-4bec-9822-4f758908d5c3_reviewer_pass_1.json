{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.routers.todos import router as todos_router\nfrom app.database import engine\n\napp = FastAPI(\n    title=\"Todo API\",\n    description=\"A simple todo application backend\",\n    version=\"1.0.0\"\n)\n\n# Configure CORS to allow all origins (adjust as needed for production)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Mount routers\napp.include_router(todos_router, prefix=\"/todos\", tags=[\"todos\"])\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    # Create database tables\n    from app.models import Base\n    Base.metadata.create_all(bind=engine)\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    # Close database connections if needed\n    pass"}, {"path": "app/models/todo.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Todo(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(default=None, nullable=False)\n    description: Optional[str] = Field(default=None, nullable=True)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas/todo.py", "content": "from pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\nclass TodoBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(BaseModel):\n    title: Optional[str]\n    description: Optional[str]\n    completed: Optional[bool]\n\nclass Todo(TodoBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/routers/todos.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.models.todo import Todo\nfrom app.schemas.todo import TodoCreate, TodoUpdate\nfrom app.services.todo_service import TodoService\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=list[Todo])\ndef get_todos(\n    skip: int = 0,\n    limit: int = 100,\n    session: Session = Depends(get_session),\n    service: TodoService = Depends(TodoService)\n) -> list[Todo]:\n    return service.get_all_todos(session, skip, limit)\n\n@router.post(\"/\", response_model=Todo, status_code=status.HTTP_201_CREATED)\ndef create_todo(\n    todo_create: TodoCreate,\n    session: Session = Depends(get_session),\n    service: TodoService = Depends(TodoService)\n) -> Todo:\n    return service.create_todo(session, todo_create)\n\n@router.get(\"/{todo_id}\", response_model=Todo)\ndef get_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n    service: TodoService = Depends(TodoService)\n) -> Todo:\n    todo = service.get_todo_by_id(session, todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.put(\"/{todo_id}\", response_model=Todo)\ndef update_todo(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    session: Session = Depends(get_session),\n    service: TodoService = Depends(TodoService)\n) -> Todo:\n    todo = service.update_todo(session, todo_id, todo_update)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n    service: TodoService = Depends(TodoService)\n):\n    if not service.delete_todo(session, todo_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")"}, {"path": "app/services/todo_service.py", "content": "from typing import List\n\nfrom app.models.todo import Todo\nfrom app.schemas.todo import TodoCreate, TodoUpdate\nfrom app.repositories.todo_repository import TodoRepository\n\nclass TodoService:\n    def __init__(self, repository: TodoRepository):\n        self.repository = repository\n\n    def get_todos(self) -> List[Todo]:\n        return self.repository.get_all()\n\n    def get_todo(self, id: int) -> Todo:\n        return self.repository.get_by_id(id)\n\n    def create_todo(self, todo_create: TodoCreate) -> Todo:\n        if not todo_create.title:\n            raise ValueError(\"Title cannot be empty\")\n        todo = Todo(\n            title=todo_create.title,\n            description=todo_create.description,\n            completed=False\n        )\n        return self.repository.create(todo)\n\n    def update_todo(self, id: int, todo_update: TodoUpdate) -> Todo:\n        todo = self.repository.get_by_id(id)\n        if todo_update.title is not None:\n            if not todo_update.title:\n                raise ValueError(\"Title cannot be empty\")\n            todo.title = todo_update.title\n        if todo_update.description is not None:\n            todo.description = todo_update.description\n        if todo_update.completed is not None:\n            todo.completed = todo_update.completed\n        return self.repository.update(todo)\n\n    def delete_todo(self, id: int) -> None:\n        self.repository.delete(id)"}, {"path": "app/repositories/todo_repository.py", "content": "from typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom app.models.todo import Todo\nfrom app.schemas.todo import TodoCreate, TodoUpdate\n\nclass TodoRepository:\n    @staticmethod\n    def get_all(db: Session) -> List[Todo]:\n        return db.query(Todo).all()\n\n    @staticmethod\n    def get_by_id(db: Session, todo_id: int) -> Optional[Todo]:\n        return db.query(Todo).filter(Todo.id == todo_id).first()\n\n    @staticmethod\n    def create(db: Session, todo_create: TodoCreate) -> Todo:\n        todo = Todo(**todo_create.dict())\n        db.add(todo)\n        db.commit()\n        db.refresh(todo)\n        return todo\n\n    @staticmethod\n    def update(db: Session, todo_id: int, todo_update: TodoUpdate) -> Optional[Todo]:\n        todo = db.query(Todo).filter(Todo.id == todo_id).first()\n        if todo:\n            update_data = todo_update.dict(exclude_unset=True)\n            for key, value in update_data.items():\n                setattr(todo, key, value)\n            db.commit()\n            db.refresh(todo)\n        return todo\n\n    @staticmethod\n    def delete(db: Session, todo_id: int) -> bool:\n        todo = db.query(Todo).filter(Todo.id == todo_id).first()\n        if todo:\n            db.delete(todo)\n            db.commit()\n            return True\n        return False"}, {"path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlmodel import SQLModel\nimport os\n\n# Database configuration\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"sqlite:///./todos.db\",\n)\n\n# Create engine\nengine = create_async_engine(DATABASE_URL, echo=True)\n\n# Create session class\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n# Dependency to get database session\nasync def get_session():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n# Create tables\nSQLModel.metadata.create_all(engine)"}, {"path": "app/models.py", "content": "from sqlmodel import SQLModel, Field\nfrom datetime import datetime\n\nclass Todo(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    title: str = Field(..., max_length=100)\n    description: str = Field(default=None, max_length=500)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass TodoBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(BaseModel):\n    title: Optional[str]\n    description: Optional[str]\n    completed: Optional[bool]\n\nclass Todo(TodoBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.services.todo_service import TodoService\nfrom app.schemas.todo import TodoCreate, TodoUpdate, TodoResponse\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=list[TodoResponse])\nasync def get_todos(session: Session = Depends(get_session)):\n    service = TodoService(session)\n    return await service.get_all()\n\n@router.post(\"/\", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)\nasync def create_todo(todo: TodoCreate, session: Session = Depends(get_session)):\n    service = TodoService(session)\n    return await service.create(todo)\n\n@router.get(\"/{id}\", response_model=TodoResponse)\nasync def get_todo(id: int, session: Session = Depends(get_session)):\n    service = TodoService(session)\n    todo = await service.get_by_id(id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.put(\"/{id}\", response_model=TodoResponse)\nasync def update_todo(id: int, todo: TodoUpdate, session: Session = Depends(get_session)):\n    service = TodoService(session)\n    updated_todo = await service.update(id, todo)\n    if not updated_todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return updated_todo\n\n@router.delete(\"/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(id: int, session: Session = Depends(get_session)):\n    service = TodoService(session)\n    success = await service.delete(id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return None"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\n# Configuration\nSECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Security utilities\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Mock user database\nfake_users_db = {\n    \"johndoe\": {\n        \"username\": \"johndoe\",\n        \"full_name\": \"John Doe\",\n        \"email\": \"johndoe@example.com\",\n        \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\",\n        \"disabled\": False,\n    }\n}\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef authenticate_user(fake_db, username: str, password: str):\n    user = fake_db.get(username)\n    if not user:\n        return False\n    if not verify_password(password, user[\"hashed_password\"]):\n        return False\n    return user\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = fake_users_db.get(username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: dict = Depends(get_current_user)):\n    if current_user[\"disabled\"]:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "pydantic", "sqlalchemy", "python-jose[cryptography]", "passlib[bcrypt]"]}