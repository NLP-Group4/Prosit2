{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.api.routes.tasks import router as tasks_router\nfrom app.database import engine\nfrom app.models import Base\n\n# Create all database tables\nBase.metadata.create_all(bind=engine)\n\napp = FastAPI(\n    title=\"Todo Application Backend\",\n    description=\"A simple REST API for task management\",\n    version=\"1.0.0\"\n)\n\n# Allow all CORS origins for development\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Register routers\napp.include_router(tasks_router, prefix=\"/tasks\", tags=[\"tasks\"])"}, {"path": "app/api/routes/tasks.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.services.task_service import TaskService\nfrom app.schemas import TaskCreate, TaskUpdate, TaskRead\n\nrouter = APIRouter()\n\n@router.post(\"/\", response_model=TaskRead, status_code=status.HTTP_201_CREATED)\ndef create_task(task: TaskCreate, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    try:\n        created_task = service.create_task(task)\n        return created_task\n    except ValueError as e:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))\n\n@router.get(\"/\", response_model=list[TaskRead])\ndef list_tasks(session: Session = Depends(get_session)):\n    service = TaskService(session)\n    return service.list_tasks()\n\n@router.get(\"/{task_id}\", response_model=TaskRead)\ndef get_task(task_id: int, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    task = service.get_task(task_id)\n    if task is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return task\n\n@router.put(\"/{task_id}\", response_model=TaskRead)\ndef update_task(task_id: int, task: TaskUpdate, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    updated_task = service.update_task(task_id, task)\n    if updated_task is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return updated_task\n\n@router.delete(\"/{task_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(task_id: int, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    deleted = service.delete_task(task_id)\n    if not deleted:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return None"}, {"path": "app/services/task_service.py", "content": "from datetime import datetime\nfrom typing import List, Optional\n\nfrom app.models import Task\nfrom app.repositories.task_repository import TaskRepository\nfrom app.schemas import TaskCreate, TaskUpdate\nfrom sqlalchemy.orm import Session\n\n\nclass TaskService:\n    def __init__(self, repository: TaskRepository):\n        self.repository = repository\n\n    def create_task(self, db: Session, task_data: TaskCreate) -> Task:\n        # Validate title is not empty\n        if not task_data.title or not task_data.title.strip():\n            raise ValueError(\"Title is required\")\n\n        # Validate no future timestamps\n        if task_data.created_at and task_data.created_at > datetime.utcnow():\n            raise ValueError(\"created_at cannot be in the future\")\n\n        # Create task entity\n        task = Task(\n            title=task_data.title,\n            description=task_data.description,\n            completed=task_data.completed,\n            created_at=task_data.created_at or datetime.utcnow(),\n            updated_at=datetime.utcnow()\n        )\n\n        # Persist to database\n        return self.repository.create(db, task)\n\n    def get_all_tasks(self, db: Session) -> List[Task]:\n        return self.repository.get_all(db)\n\n    def get_task_by_id(self, db: Session, task_id: int) -> Optional[Task]:\n        return self.repository.get_by_id(db, task_id)\n\n    def update_task(self, db: Session, task_id: int, task_data: TaskUpdate) -> Task:\n        # Validate no future timestamps\n        if task_data.updated_at and task_data.updated_at > datetime.utcnow():\n            raise ValueError(\"updated_at cannot be in the future\")\n\n        # Get existing task\n        task = self.repository.get_by_id(db, task_id)\n        if not task:\n            raise ValueError(f\"Task with id {task_id} not found\")\n\n        # Update fields\n        if task_data.title is not None:\n            if not task_data.title.strip():\n                raise ValueError(\"Title cannot be empty\")\n            task.title = task_data.title\n\n        if task_data.description is not None:\n            task.description = task_data.description\n\n        if task_data.completed is not None:\n            task.completed = task_data.completed\n\n        if task_data.updated_at is not None:\n            task.updated_at = task_data.updated_at\n        else:\n            task.updated_at = datetime.utcnow()\n\n        # Persist updates\n        return self.repository.update(db, task)\n\n    def delete_task(self, db: Session, task_id: int) -> bool:\n        task = self.repository.get_by_id(db, task_id)\n        if not task:\n            raise ValueError(f\"Task with id {task_id} not found\")\n\n        return self.repository.delete(db, task)"}, {"path": "app/repositories/task_repository.py", "content": "from typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom app.models import Task\nfrom app.schemas import TaskCreate, TaskUpdate\n\nclass TaskRepository:\n    @staticmethod\n    def get_task(db: Session, task_id: int) -> Optional[Task]:\n        return db.query(Task).filter(Task.id == task_id).first()\n\n    @staticmethod\n    def get_tasks(db: Session, skip: int = 0, limit: int = 100) -> List[Task]:\n        return db.query(Task).offset(skip).limit(limit).all()\n\n    @staticmethod\n    def create_task(db: Session, task: TaskCreate) -> Task:\n        db_task = Task(**task.dict())\n        db.add(db_task)\n        db.commit()\n        db.refresh(db_task)\n        return db_task\n\n    @staticmethod\n    def update_task(db: Session, task_id: int, task: TaskUpdate) -> Optional[Task]:\n        db_task = db.query(Task).filter(Task.id == task_id).first()\n        if db_task is None:\n            return None\n\n        update_data = task.dict(exclude_unset=True)\n        for key, value in update_data.items():\n            setattr(db_task, key, value)\n\n        db.commit()\n        db.refresh(db_task)\n        return db_task\n\n    @staticmethod\n    def delete_task(db: Session, task_id: int) -> bool:\n        db_task = db.query(Task).filter(Task.id == task_id).first()\n        if db_task is None:\n            return False\n\n        db.delete(db_task)\n        db.commit()\n        return True"}, {"path": "app/models/task.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\nclass Task(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(default=None, nullable=False)\n    description: Optional[str] = Field(default=None)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\n\nclass TaskCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    completed: bool = False\n\nclass TaskUpdate(BaseModel):\n    title: Optional[str] = Field(None, min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    completed: Optional[bool] = None\n\nclass TaskResponse(BaseModel):\n    id: int\n    title: str\n    description: Optional[str]\n    completed: bool\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlmodel import SQLModel\n\n# Database configuration\nDATABASE_URL = \"sqlite:///./todo.db\"\n\n# Create SQLAlchemy engine\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\n\n# Create SQLModel base\nBase = SQLModel\n\n# Create configured \"Session\" class\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Dependency to get a database session\ndef get_session() -> Session:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()"}, {"path": "app/models.py", "content": "from sqlmodel import SQLModel, Field\nfrom datetime import datetime\n\nclass Task(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    title: str\n    description: str = Field(default=None)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\nfrom app.database import get_session\nfrom app.models import Task\nfrom app.schemas import TaskCreate, TaskUpdate\nfrom app.services.task_service import TaskService\n\nrouter = APIRouter()\n\n@router.post(\"/\", response_model=Task, status_code=status.HTTP_201_CREATED)\ndef create_task(task_data: TaskCreate, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    task = service.create_task(task_data)\n    return task\n\n@router.get(\"/\", response_model=List[Task])\ndef list_tasks(session: Session = Depends(get_session)):\n    service = TaskService(session)\n    tasks = service.list_tasks()\n    return tasks\n\n@router.get(\"/{task_id}\", response_model=Task)\ndef get_task(task_id: int, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    task = service.get_task(task_id)\n    if task is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return task\n\n@router.put(\"/{task_id}\", response_model=Task)\ndef update_task(task_id: int, task_data: TaskUpdate, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    task = service.update_task(task_id, task_data)\n    if task is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return task\n\n@router.delete(\"/{task_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(task_id: int, session: Session = Depends(get_session)):\n    service = TaskService(session)\n    success = service.delete_task(task_id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Task not found\")\n    return None"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom app.config import settings\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# JWT token setup\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Token verification\ndef verify_token(token: str = Depends(oauth2_scheme)) -> dict:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        return payload\n    except JWTError:\n        raise credentials_exception\n\n# Password verification\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n# Password hashing\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n# Authentication dependency\ndef get_current_user(token: str = Depends(oauth2_scheme)) -> dict:\n    return verify_token(token)"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}