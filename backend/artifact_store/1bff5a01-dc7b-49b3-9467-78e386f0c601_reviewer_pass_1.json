{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nimport logging\n\nfrom app.routes import router as api_router\nfrom app.database import init_db\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"app.main\")\n\napp = FastAPI(title=\"Minimal Calculator API\", version=\"0.1.0\")\n\napp.include_router(api_router)\n\n\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    logger.info(\"Starting up application and initializing database...\")\n    init_db()\n    logger.info(\"Database initialization complete.\")"}, {"path": "app/database.py", "content": "import os\nimport logging\nfrom typing import Generator, Optional\n\nfrom sqlmodel import SQLModel, create_engine, Session\nfrom sqlalchemy.orm import sessionmaker\n\nlogger = logging.getLogger(__name__)\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./calculations.db\")\n\n# SQLite needs this flag to allow usage from multiple threads\nconnect_args: Optional[dict] = {\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else None\n\n# create_engine accepts connect_args only when not None\n_engine = create_engine(DATABASE_URL, echo=False, connect_args=connect_args)  # type: ignore[arg-type]\n\n# Session factory using SQLModel's Session class\nSessionLocal = sessionmaker(bind=_engine, class_=Session, expire_on_commit=False)\n\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency for FastAPI routes. Yields a SQLModel Session and ensures it is closed after use.\n    Usage:\n        def endpoint(session: Session = Depends(get_session)):\n            ...\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\n\ndef init_db() -> None:\n    \"\"\"\n    Create database tables for all SQLModel models.\n    Call this at application startup to ensure tables exist.\n    \"\"\"\n    logger.info(\"Initializing database and creating tables (if not present).\")\n    SQLModel.metadata.create_all(_engine)\n\n\n# Expose engine for other modules if needed\nengine = _engine"}, {"path": "app/models.py", "content": "from typing import Optional\nfrom datetime import datetime\nfrom sqlmodel import SQLModel, Field\n\n\nclass Calculation(SQLModel, table=True):\n    \"\"\"\n    Calculation table mapping.\n\n    Fields:\n    - id: primary key, auto-increment\n    - operand1: first operand (float)\n    - operand2: second operand (float)\n    - operation: operation name ('add', 'sub', 'mul', 'div')\n    - result: result of the calculation, null if error occurred\n    - error: error message if any, null otherwise\n    - created_at: timestamp of creation (UTC)\n    \"\"\"\n    __tablename__ = \"calculations\"\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    operand1: float\n    operand2: float\n    operation: str = Field(index=True, description=\"Operation: add|sub|mul|div\")\n    result: Optional[float] = None\n    error: Optional[str] = None\n    created_at: datetime = Field(default_factory=lambda: datetime.utcnow())"}, {"path": "app/schemas.py", "content": "from typing import Optional\nfrom datetime import datetime\nfrom sqlmodel import SQLModel, Field\nfrom pydantic import validator, BaseModel\n\n\n_OPERATION_ALIASES = {\n    \"+\": \"add\",\n    \"-\": \"sub\",\n    \"*\": \"mul\",\n    \"/\": \"div\",\n}\n_VALID_OPERATIONS = {\"add\", \"sub\", \"mul\", \"div\"}\n\n\nclass CalculateRequest(SQLModel):\n    operand1: float\n    operand2: float\n    operation: str\n\n    @validator(\"operation\", pre=True)\n    def normalize_operation(cls, v: str) -> str:\n        if not isinstance(v, str):\n            raise ValueError(\"operation must be a string\")\n        token = v.strip().lower()\n        # Map operator symbols to names\n        if token in _OPERATION_ALIASES:\n            token = _OPERATION_ALIASES[token]\n        if token not in _VALID_OPERATIONS:\n            raise ValueError(f\"unsupported operation '{v}'\")\n        return token\n\n    class Config:\n        anystr_strip_whitespace = True\n        schema_extra = {\n            \"example\": {\"operand1\": 2.0, \"operand2\": 3.0, \"operation\": \"add\"}\n        }\n\n\nclass CalculationRead(SQLModel):\n    id: int\n    operand1: float\n    operand2: float\n    operation: str\n    result: Optional[float] = None\n    error: Optional[str] = None\n    created_at: datetime = Field(..., description=\"ISO8601 timestamp\")\n\n    class Config:\n        orm_mode = True\n        schema_extra = {\n            \"example\": {\n                \"id\": 1,\n                \"operand1\": 2.0,\n                \"operand2\": 3.0,\n                \"operation\": \"add\",\n                \"result\": 5.0,\n                \"error\": None,\n                \"created_at\": \"2026-02-27T12:34:56Z\",\n            }\n        }\n\n\nclass ErrorResponse(BaseModel):\n    error: str\n    code: str\n\n    class Config:\n        schema_extra = {\"example\": {\"error\": \"Division by zero\", \"code\": \"DivisionByZero\"}}"}, {"path": "app/routes.py", "content": "from typing import List, Optional\nfrom datetime import datetime, timezone\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\n\nfrom app.database import get_session\nfrom app.models import Calculation\nfrom app.schemas import CalculateRequest, CalculationResponse\nfrom app.core import (\n    calculate,\n    InvalidInputError,\n    DivisionByZeroError,\n    CalculationError,\n)\nfrom app import repository\nfrom app.auth import get_current_user\n\nrouter = APIRouter()\n\n\n@router.post(\"/calculate\", response_model=CalculationResponse, status_code=200, tags=[\"calculate\"])\nasync def post_calculate(\n    payload: CalculateRequest, session=Depends(get_session)\n) -> Calculation:\n    \"\"\"\n    Perform a calculation, store the result (or error) and return the stored record.\n    Domain errors like invalid input or division by zero return structured 400 responses.\n    \"\"\"\n    try:\n        result, error = calculate(payload.operand1, payload.operand2, payload.operation)\n    except InvalidInputError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": str(exc), \"code\": \"InvalidInput\"},\n        )\n    except DivisionByZeroError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": str(exc), \"code\": \"DivisionByZero\"},\n        )\n    except CalculationError as exc:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail={\"error\": str(exc), \"code\": \"CalculationError\"},\n        )\n\n    # If core returned a domain error in tuple form, surface it as 400\n    if error is not None:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail={\"error\": error, \"code\": \"InvalidInput\"},\n        )\n\n    # Build calculation record\n    calc = Calculation(\n        operand1=payload.operand1,\n        operand2=payload.operand2,\n        operation=payload.operation.lower(),\n        result=result,\n        error=None,\n        created_at=datetime.now(timezone.utc),\n    )\n\n    created = repository.create_calculation(session, calc)\n    return created\n\n\n@router.get(\n    \"/calculations\",\n    response_model=List[CalculationResponse],\n    status_code=200,\n    tags=[\"calculations\"],\n)\nasync def list_calculations(\n    limit: int = 100,\n    offset: int = 0,\n    session=Depends(get_session),\n    current_user=Depends(get_current_user),\n) -> List[Calculation]:\n    \"\"\"\n    List stored calculations. Protected endpoint (requires authentication).\n    Supports pagination via limit and offset.\n    \"\"\"\n    limit = max(1, min(1000, limit))\n    offset = max(0, offset)\n    items = repository.list_calculations(session, limit=limit, offset=offset)\n    return items\n\n\n@router.get(\n    \"/calculations/{calc_id}\",\n    response_model=CalculationResponse,\n    status_code=200,\n    tags=[\"calculations\"],\n)\nasync def get_calculation(\n    calc_id: int,\n    session=Depends(get_session),\n    current_user=Depends(get_current_user),\n) -> Calculation:\n    \"\"\"\n    Retrieve a single calculation by id. Protected endpoint.\n    \"\"\"\n    item = repository.get_calculation(session, calc_id)\n    if item is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail={\"error\": \"Calculation not found\", \"code\": \"NotFound\"},\n        )\n    return item"}, {"path": "app/core.py", "content": "from typing import Optional, Tuple, Dict\nimport numbers\n\n\nclass CalculationError(Exception):\n    \"\"\"\n    Base class for calculation domain errors.\n    Attributes:\n        message: human readable message\n        code: machine-friendly error code\n    \"\"\"\n    code: str = \"CalculationError\"\n\n    def __init__(self, message: str):\n        super().__init__(message)\n        self.message = message\n\n\nclass InvalidInputError(CalculationError):\n    code = \"InvalidInput\"\n\n    def __init__(self, message: str = \"Invalid input\"):\n        super().__init__(message)\n\n\nclass DivisionByZeroError(CalculationError):\n    code = \"DivisionByZero\"\n\n    def __init__(self, message: str = \"Division by zero\"):\n        super().__init__(message)\n\n\n# Supported operations mapping: accepts canonical names and common operator aliases.\n_OPERATION_ALIASES = {\n    \"add\": \"add\",\n    \"+\": \"add\",\n    \"plus\": \"add\",\n    \"sub\": \"sub\",\n    \"subtract\": \"sub\",\n    \"-\": \"sub\",\n    \"minus\": \"sub\",\n    \"mul\": \"mul\",\n    \"multiply\": \"mul\",\n    \"*\": \"mul\",\n    \"times\": \"mul\",\n    \"div\": \"div\",\n    \"divide\": \"div\",\n    \"/\": \"div\",\n}\n\n\ndef _normalize_operation(operation: str) -> str:\n    if not isinstance(operation, str):\n        raise InvalidInputError(\"Operation must be a string\")\n    key = operation.strip().lower()\n    if key not in _OPERATION_ALIASES:\n        raise InvalidInputError(f\"Unsupported operation: {operation}\")\n    return _OPERATION_ALIASES[key]\n\n\ndef _validate_operand(value, name: str) -> float:\n    # Accept ints and floats (numbers.Real), reject NaN/Inf\n    if not isinstance(value, numbers.Real):\n        raise InvalidInputError(f\"{name} must be a number\")\n    # numbers.Real includes bool, exclude bool explicitly\n    if isinstance(value, bool):\n        raise InvalidInputError(f\"{name} must be a number\")\n    val = float(value)\n    if val != val:  # NaN check\n        raise InvalidInputError(f\"{name} must be a finite number\")\n    if val in (float(\"inf\"), float(\"-inf\")):\n        raise InvalidInputError(f\"{name} must be a finite number\")\n    return val\n\n\ndef calculate(operand1: float, operand2: float, operation: str) -> float:\n    \"\"\"\n    Perform a calculation.\n\n    Args:\n        operand1: left operand (number).\n        operand2: right operand (number).\n        operation: operation name or alias (e.g., \"add\", \"+\", \"DIV\", \"/\").\n\n    Returns:\n        result as float\n\n    Raises:\n        InvalidInputError: if inputs are invalid or operation unsupported.\n        DivisionByZeroError: if dividing by zero.\n        CalculationError: for other calculation-related errors.\n    \"\"\"\n    a = _validate_operand(operand1, \"operand1\")\n    b = _validate_operand(operand2, \"operand2\")\n    op = _normalize_operation(operation)\n\n    try:\n        if op == \"add\":\n            return a + b\n        elif op == \"sub\":\n            return a - b\n        elif op == \"mul\":\n            return a * b\n        elif op == \"div\":\n            if b == 0.0:\n                raise DivisionByZeroError(\"Division by zero\")\n            return a / b\n        else:\n            # Defensive; should not happen due to normalization\n            raise InvalidInputError(f\"Unsupported operation: {operation}\")\n    except CalculationError:\n        # Re-raise domain errors unchanged\n        raise\n    except Exception as exc:\n        # Wrap unexpected errors\n        raise CalculationError(f\"Internal calculation error: {exc}\") from exc\n\n\ndef calculate_safe(operand1: float, operand2: float, operation: str) -> Tuple[Optional[float], Optional[Dict[str, str]]]:\n    \"\"\"\n    Safe wrapper around calculate that returns a (result, error) tuple instead\n    of raising. The error, if present, is a dict with keys 'code' and 'message'.\n\n    Returns:\n        (result, None) on success\n        (None, {\"code\": ..., \"message\": ...}) on known domain errors\n        (None, {\"code\": \"CalculationError\", \"message\": \"...\"}) on unexpected errors\n    \"\"\"\n    try:\n        result = calculate(operand1, operand2, operation)\n        return result, None\n    except CalculationError as ce:\n        return None, {\"code\": getattr(ce, \"code\", \"CalculationError\"), \"message\": ce.message}\n    except Exception as exc:\n        return None, {\"code\": \"CalculationError\", \"message\": str(exc)}"}, {"path": "app/repository.py", "content": "import threading\nfrom typing import List, Optional\n\nfrom sqlmodel import Session, select\n\nfrom app.models import Calculation\n\n\nclass CalculationRepository:\n    \"\"\"\n    Repository for Calculation records using SQLModel sessions.\n\n    All public methods acquire an internal threading.Lock to ensure thread-safety\n    when used from a multi-threaded environment (e.g., FastAPI).\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n\n    def create(self, session: Session, calc: Calculation) -> Calculation:\n        \"\"\"\n        Persist a Calculation instance and return the stored model (with id and defaults populated).\n        \"\"\"\n        with self._lock:\n            session.add(calc)\n            session.commit()\n            session.refresh(calc)\n            return calc\n\n    def list(self, session: Session, limit: int = 100, offset: int = 0) -> List[Calculation]:\n        \"\"\"\n        Return a list of Calculation records with pagination.\n        \"\"\"\n        with self._lock:\n            statement = select(Calculation).offset(offset).limit(limit).order_by(Calculation.id)\n            results = session.exec(statement).all()\n            return results\n\n    def get(self, session: Session, id: int) -> Optional[Calculation]:\n        \"\"\"\n        Retrieve a single Calculation by id or return None if not found.\n        \"\"\"\n        with self._lock:\n            statement = select(Calculation).where(Calculation.id == id)\n            result = session.exec(statement).first()\n            return result\n\n\n# convenience single repository instance\nrepository = CalculationRepository()"}, {"path": "app/auth.py", "content": "from datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\n\n# Secret key - in real deployments keep this secret and out of source control\nSECRET_KEY = \"change-me-please-use-a-secure-random-key\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60\n\n# OAuth2 scheme. tokenUrl should match the actual token route used by the application.\n# The application should provide a POST /token route that exchanges username/password for a token.\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\")\n\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n\n# Minimal in-memory user \"database\"\n# Passwords stored hashed. For demo purposes we include one user.\ndef _hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\n\n_users_db: Dict[str, Dict[str, Any]] = {\n    \"alice\": {\n        \"username\": \"alice\",\n        \"full_name\": \"Alice Example\",\n        \"email\": \"alice@example.com\",\n        \"hashed_password\": _hash_password(\"secret\"),\n        \"disabled\": False,\n    }\n}\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_user(username: str) -> Optional[Dict[str, Any]]:\n    user = _users_db.get(username)\n    return user\n\n\ndef authenticate_user(username: str, password: str) -> Optional[Dict[str, Any]]:\n    user = get_user(username)\n    if not user:\n        return None\n    if not verify_password(password, user[\"hashed_password\"]):\n        return None\n    return user\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    now = datetime.utcnow()\n    if expires_delta:\n        expire = now + expires_delta\n    else:\n        expire = now + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire, \"iat\": now})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> Dict[str, Any]:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: Optional[str] = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    user = get_user(token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_active_user(current_user: Dict[str, Any] = Depends(get_current_user)) -> Dict[str, Any]:\n    if current_user.get(\"disabled\"):\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}