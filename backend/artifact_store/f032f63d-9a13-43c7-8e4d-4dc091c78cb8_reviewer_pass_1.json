{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI, Request, status, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\nfrom sqlmodel import SQLModel\n\nfrom app.database import engine, create_db_and_tables\nfrom app.routes import auth_router, task_router\n\napp = FastAPI(\n    title=\"Todo Application API\",\n    description=\"REST API for task management with authentication\",\n    version=\"1.0.0\",\n)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize database tables on startup.\"\"\"\n    create_db_and_tables()\n\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    \"\"\"Handle unhandled exceptions.\"\"\"\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal server error\"},\n    )\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"Handle request validation errors.\"\"\"\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            \"field\": \".\".join(str(loc) for loc in error[\"loc\"]),\n            \"message\": error[\"msg\"],\n        })\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content={\"detail\": \"Validation error\", \"errors\": errors},\n    )\n\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    \"\"\"Handle HTTP exceptions.\"\"\"\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"detail\": exc.detail},\n    )\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"message\": \"Todo Application API\", \"version\": \"1.0.0\"}\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n\n\n# Include routers\napp.include_router(auth_router, prefix=\"/api/auth\", tags=[\"Authentication\"])\napp.include_router(task_router, prefix=\"/api/tasks\", tags=[\"Tasks\"])\n</think>\n\nfrom fastapi import FastAPI, Request, status, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\nfrom sqlmodel import SQLModel\n\nfrom app.database import engine, create_db_and_tables\nfrom app.routes import auth_router, task_router\n\napp = FastAPI(\n    title=\"Todo Application API\",\n    description=\"REST API for task management with authentication\",\n    version=\"1.0.0\",\n)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize database tables on startup.\"\"\"\n    create_db_and_tables()\n\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    \"\"\"Handle unhandled exceptions.\"\"\"\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal server error\"},\n    )\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"Handle request validation errors.\"\"\"\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            \"field\": \".\".join(str(loc) for loc in error[\"loc\"]),\n            \"message\": error[\"msg\"],\n        })\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content={\"detail\": \"Validation error\", \"errors\": errors},\n    )\n\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    \"\"\"Handle HTTP exceptions.\"\"\"\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"detail\": exc.detail},\n    )\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"message\": \"Todo Application API\", \"version\": \"1.0.0\"}\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n\n\n# Include routers\napp.include_router(auth_router, prefix=\"/api/auth\", tags=[\"Authentication\"])\napp.include_router(task_router, prefix=\"/api/tasks\", tags=[\"Tasks\"])"}, {"path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlmodel import SQLModel, Session as SQLModelSession\nfrom typing import Generator\nimport os\n\n# Database URL from environment variable, default to SQLite\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///./todo.db\")\n\n# Create engine with appropriate settings for SQLite\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False} if \"sqlite\" in DATABASE_URL else {},\n    echo=os.getenv(\"DATABASE_ECHO\", \"false\").lower() == \"true\"\n)\n\n# Session factory\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef get_session() -> Generator[Session, None, None]:\n    \"\"\"Dependency to get database session.\"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n    finally:\n        session.close()\n\ndef create_db_and_tables():\n    \"\"\"Create all database tables.\"\"\"\n    SQLModel.metadata.create_all(engine)\n\ndef get_session_model() -> Generator[SQLModelSession, None, None]:\n    \"\"\"Dependency to get SQLModel session.\"\"\"\n    with SQLModelSession(engine) as session:\n        yield session"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom typing import Optional, List\nfrom sqlmodel import SQLModel, Field, Relationship\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"users\"\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    username: str = Field(unique=True, index=True)\n    email: str = Field(unique=True, index=True)\n    password_hash: str\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n\n    tasks: List[\"Task\"] = Relationship(back_populates=\"user\", cascade_delete=True)\n\n\nclass Task(SQLModel, table=True):\n    __tablename__ = \"tasks\"\n\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"users.id\", index=True)\n    title: str\n    description: Optional[str] = None\n    completed: bool = Field(default=False, index=True)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow, sa_column_kwargs={\"onupdate\": datetime.utcnow})\n\n    user: Optional[\"User\"] = Relationship(back_populates=\"tasks\")"}, {"path": "app/schemas.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, field_validator\n\n\nclass UserBase(BaseModel):\n    \"\"\"Base schema for user data.\"\"\"\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n\n\nclass UserCreate(UserBase):\n    \"\"\"Schema for user registration.\"\"\"\n    password: str = Field(..., min_length=6, max_length=100)\n    \n    @field_validator('password')\n    @classmethod\n    def validate_password(cls, v: str) -> str:\n        if len(v) < 6:\n            raise ValueError('Password must be at least 6 characters long')\n        return v\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Schema for user login.\"\"\"\n    email: EmailStr\n    password: str\n\n\nclass UserResponse(UserBase):\n    \"\"\"Schema for user response.\"\"\"\n    id: int\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass TaskBase(BaseModel):\n    \"\"\"Base schema for task data.\"\"\"\n    title: str = Field(..., min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=1000)\n    completed: bool = False\n\n\nclass TaskCreate(TaskBase):\n    \"\"\"Schema for creating a task.\"\"\"\n    pass\n\n\nclass TaskUpdate(BaseModel):\n    \"\"\"Schema for updating a task.\"\"\"\n    title: Optional[str] = Field(None, min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=1000)\n    completed: Optional[bool] = None\n\n\nclass TaskResponse(TaskBase):\n    \"\"\"Schema for task response.\"\"\"\n    id: int\n    user_id: int\n    created_at: datetime\n    updated_at: datetime\n    \n    class Config:\n        from_attributes = True\n\n\nclass Token(BaseModel):\n    \"\"\"Schema for JWT token response.\"\"\"\n    access_token: str\n    token_type: str = \"bearer\"\n\n\nclass TokenData(BaseModel):\n    \"\"\"Schema for token payload data.\"\"\"\n    user_id: Optional[int] = None"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\nfrom app.database import get_session\nfrom app.models import User, Task\nfrom app.schemas import UserCreate, UserLogin, UserResponse, TaskCreate, TaskUpdate, TaskResponse, TokenResponse\nfrom app.auth import create_access_token, verify_password, get_current_user\n\nrouter = APIRouter(prefix=\"/api\", tags=[\"Authentication\", \"Tasks\"])\n\n\n@router.post(\"/auth/register\", response_model=UserResponse, status_code=status.HTTP_201_CREATED)\ndef register(user_data: UserCreate, session: Session = Depends(get_session)):\n    \"\"\"Register a new user with username, email, and password.\"\"\"\n    existing_user = session.query(User).filter(\n        (User.username == user_data.username) | (User.email == user_data.email)\n    ).first()\n    \n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Username or email already registered\"\n        )\n    \n    hashed_password = verify_password(user_data.password)\n    \n    new_user = User(\n        username=user_data.username,\n        email=user_data.email,\n        password_hash=hashed_password\n    )\n    \n    session.add(new_user)\n    session.commit()\n    session.refresh(new_user)\n    \n    return new_user\n\n\n@router.post(\"/auth/login\", response_model=TokenResponse)\ndef login(user_data: UserLogin, session: Session = Depends(get_session)):\n    \"\"\"Authenticate user and return JWT token.\"\"\"\n    user = session.query(User).filter(User.email == user_data.email).first()\n    \n    if not user or not verify_password(user_data.password, user.password_hash):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid email or password\"\n        )\n    \n    access_token = create_access_token(user_id=user.id)\n    \n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n\n@router.post(\"/tasks\", response_model=TaskResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(task_data: TaskCreate, session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Create a new task for the authenticated user.\"\"\"\n    new_task = Task(\n        user_id=current_user.id,\n        title=task_data.title,\n        description=task_data.description,\n        completed=task_data.completed\n    )\n    \n    session.add(new_task)\n    session.commit()\n    session.refresh(new_task)\n    \n    return new_task\n\n\n@router.get(\"/tasks\", response_model=List[TaskResponse])\ndef get_tasks(session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Get all tasks for the authenticated user.\"\"\"\n    tasks = session.query(Task).filter(Task.user_id == current_user.id).all()\n    \n    return tasks\n\n\n@router.get(\"/tasks/filter\", response_model=List[TaskResponse])\ndef filter_tasks(completed: bool = False, session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Filter tasks by completion status for the authenticated user.\"\"\"\n    tasks = session.query(Task).filter(\n        Task.user_id == current_user.id,\n        Task.completed == completed\n    ).all()\n    \n    return tasks\n\n\n@router.get(\"/tasks/{task_id}\", response_model=TaskResponse)\ndef get_task(task_id: int, session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Get a specific task by ID for the authenticated user.\"\"\"\n    task = session.query(Task).filter(\n        Task.id == task_id,\n        Task.user_id == current_user.id\n    ).first()\n    \n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n    \n    return task\n\n\n@router.put(\"/tasks/{task_id}\", response_model=TaskResponse)\ndef update_task(task_id: int, task_data: TaskUpdate, session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Update a task by ID for the authenticated user.\"\"\"\n    task = session.query(Task).filter(\n        Task.id == task_id,\n        Task.user_id == current_user.id\n    ).first()\n    \n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n    \n    update_data = task_data.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(task, field, value)\n    \n    session.commit()\n    session.refresh(task)\n    \n    return task\n\n\n@router.delete(\"/tasks/{task_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(task_id: int, session: Session = Depends(get_session), current_user: User = Depends(get_current_user)):\n    \"\"\"Delete a task by ID for the authenticated user.\"\"\"\n    task = session.query(Task).filter(\n        Task.id == task_id,\n        Task.user_id == current_user.id\n    ).first()\n    \n    if not task:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Task not found\"\n        )\n    \n    session.delete(task)\n    session.commit()\n    \n    return None"}, {"path": "app/auth.py", "content": "from datetime import datetime, timedelta, timezone\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlmodel import Session, select\n\nfrom app.database import get_session\nfrom app.models import User\nfrom app.schemas import TokenData\n\n# Configuration\nSECRET_KEY = \"your-secret-key-change-in-production\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Password hashing context\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme for token validation\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/auth/login\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a plain password against a hashed password.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Generate a hashed password from plain text.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n\n\ndef decode_access_token(token: str) -> Optional[dict]:\n    \"\"\"Decode and validate a JWT access token.\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    session: Session = Depends(get_session)\n) -> User:\n    \"\"\"\n    Dependency to get the current authenticated user from JWT token.\n    Raises HTTPException with 401 status if token is invalid or user not found.\n    \"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    payload = decode_access_token(token)\n    if payload is None:\n        raise credentials_exception\n    \n    user_id: int = payload.get(\"sub\")\n    if user_id is None:\n        raise credentials_exception\n    \n    statement = select(User).where(User.id == user_id)\n    user = session.exec(statement).first()\n    \n    if user is None:\n        raise credentials_exception\n    \n    return user\n\n\nasync def get_current_active_user(\n    current_user: User = Depends(get_current_user)\n) -> User:\n    \"\"\"\n    Dependency to get the current active user.\n    Can be extended to check user status (e.g., is_active flag).\n    \"\"\"\n    return current_user\n\n\nasync def get_current_user_optional(\n    token: Optional[str] = Depends(oauth2_scheme),\n    session: Session = Depends(get_session)\n) -> Optional[User]:\n    \"\"\"\n    Optional dependency that returns user if token is valid, None otherwise.\n    Useful for endpoints that work with or without authentication.\n    \"\"\"\n    if token is None:\n        return None\n    \n    payload = decode_access_token(token)\n    if payload is None:\n        return None\n    \n    user_id: int = payload.get(\"sub\")\n    if user_id is None:\n        return None\n    \n    statement = select(User).where(User.id == user_id)\n    user = session.exec(statement).first()\n    \n    return user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "python-jose[cryptography]", "passlib[bcrypt]"]}