{"files": [{"path": "app/main.py", "content": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.api.routes import todos\n\napp = FastAPI(\n    title=\"Todo App Backend\",\n    description=\"A lightweight REST API for managing todo items\",\n    version=\"1.0.0\"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\napp.include_router(todos.router, prefix=\"/todos\", tags=[\"todos\"])"}, {"path": "app/api/routes/todos.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.services.todo_service import TodoService\nfrom app.schemas.todo import TodoCreate, TodoUpdate, TodoResponse\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=list[TodoResponse])\nasync def get_todos(\n    completed: bool | None = None,\n    session: Session = Depends(get_session),\n) -> list[TodoResponse]:\n    service = TodoService(session)\n    todos = await service.get_todos(completed=completed)\n    return todos\n\n@router.post(\"/\", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo_create: TodoCreate,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    service = TodoService(session)\n    todo = await service.create_todo(todo_create)\n    return todo\n\n@router.get(\"/{todo_id}\", response_model=TodoResponse)\nasync def get_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    service = TodoService(session)\n    todo = await service.get_todo(todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.put(\"/{todo_id}\", response_model=TodoResponse)\nasync def update_todo(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    service = TodoService(session)\n    todo = await service.update_todo(todo_id, todo_update)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> None:\n    service = TodoService(session)\n    success = await service.delete_todo(todo_id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n\n@router.patch(\"/{todo_id}/complete\", response_model=TodoResponse)\nasync def toggle_todo_complete(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    service = TodoService(session)\n    todo = await service.toggle_todo_complete(todo_id)\n    if not todo:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found\")\n    return todo"}, {"path": "app/services/todo_service.py", "content": "from typing import List, Optional\nfrom datetime import datetime\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.models.todo import Todo\nfrom app.repositories.todo_repository import TodoRepository\nfrom app.schemas.todo import TodoCreate, TodoUpdate, TodoResponse\n\nclass TodoService:\n    def __init__(self, repository: TodoRepository):\n        self.repository = repository\n\n    async def create_todo(self, db: AsyncSession, todo_create: TodoCreate) -> TodoResponse:\n        # Validate title is not empty\n        if not todo_create.title.strip():\n            raise ValueError(\"Title cannot be empty\")\n\n        # Validate due_date is in the future if provided\n        if todo_create.due_date and todo_create.due_date <= datetime.now():\n            raise ValueError(\"Due date must be in the future\")\n\n        todo = await self.repository.create(db, todo_create)\n        return TodoResponse.from_orm(todo)\n\n    async def get_all_todos(self, db: AsyncSession) -> List[TodoResponse]:\n        todos = await self.repository.get_all(db)\n        return [TodoResponse.from_orm(todo) for todo in todos]\n\n    async def get_todo_by_id(self, db: AsyncSession, todo_id: int) -> Optional[TodoResponse]:\n        todo = await self.repository.get_by_id(db, todo_id)\n        return TodoResponse.from_orm(todo) if todo else None\n\n    async def update_todo(self, db: AsyncSession, todo_id: int, todo_update: TodoUpdate) -> Optional[TodoResponse]:\n        todo = await self.repository.get_by_id(db, todo_id)\n        if not todo:\n            return None\n\n        # Validate title is not empty if being updated\n        if todo_update.title is not None and not todo_update.title.strip():\n            raise ValueError(\"Title cannot be empty\")\n\n        # Validate due_date is in the future if being updated\n        if todo_update.due_date is not None and todo_update.due_date <= datetime.now():\n            raise ValueError(\"Due date must be in the future\")\n\n        # If todo is completed, only allow completion status changes\n        if todo.completed and any(field is not None for field in [todo_update.title, todo_update.description, todo_update.due_date]):\n            raise ValueError(\"Cannot modify completed todo except for completion status\")\n\n        updated_todo = await self.repository.update(db, todo_id, todo_update)\n        return TodoResponse.from_orm(updated_todo)\n\n    async def delete_todo(self, db: AsyncSession, todo_id: int) -> bool:\n        todo = await self.repository.get_by_id(db, todo_id)\n        if not todo:\n            return False\n\n        await self.repository.delete(db, todo_id)\n        return True\n\n    async def toggle_completion(self, db: AsyncSession, todo_id: int) -> Optional[TodoResponse]:\n        todo = await self.repository.get_by_id(db, todo_id)\n        if not todo:\n            return None\n\n        todo_update = TodoUpdate(completed=not todo.completed)\n        updated_todo = await self.repository.update(db, todo_id, todo_update)\n        return TodoResponse.from_orm(updated_todo)"}, {"path": "app/repositories/todo_repository.py", "content": "from typing import List, Optional\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlmodel import select, update\n\nfrom app.models import Todo\n\n\nclass TodoRepository:\n    @staticmethod\n    async def get_all(db: AsyncSession) -> List[Todo]:\n        \"\"\"Retrieve all todos from the database.\"\"\"\n        result = await db.execute(select(Todo))\n        return result.scalars().all()\n\n    @staticmethod\n    async def get_by_id(db: AsyncSession, todo_id: int) -> Optional[Todo]:\n        \"\"\"Retrieve a todo by its ID.\"\"\"\n        result = await db.execute(select(Todo).where(Todo.id == todo_id))\n        return result.scalar_one_or_none()\n\n    @staticmethod\n    async def create(db: AsyncSession, todo: Todo) -> Todo:\n        \"\"\"Create a new todo in the database.\"\"\"\n        db.add(todo)\n        await db.commit()\n        await db.refresh(todo)\n        return todo\n\n    @staticmethod\n    async def update(db: AsyncSession, todo_id: int, updates: dict) -> Optional[Todo]:\n        \"\"\"Update an existing todo.\"\"\"\n        result = await db.execute(\n            update(Todo)\n            .where(Todo.id == todo_id)\n            .values(**updates)\n            .returning(Todo)\n        )\n        return result.scalar_one_or_none()\n\n    @staticmethod\n    async def delete(db: AsyncSession, todo_id: int) -> bool:\n        \"\"\"Delete a todo by its ID.\"\"\"\n        result = await db.execute(\n            Todo.__table__.delete().where(Todo.id == todo_id)\n        )\n        await db.commit()\n        return result.rowcount > 0"}, {"path": "app/models/todo.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import Field, SQLModel\n\n\nclass Todo(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(default=None, nullable=False)\n    description: Optional[str] = Field(default=None)\n    due_date: Optional[datetime] = Field(default=None)\n    completed: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\n    __tablename__ = \"todos\"\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if \"title\" in data and not data[\"title\"].strip():\n            raise ValueError(\"Title cannot be empty\")\n        if \"due_date\" in data and data[\"due_date\"] and data[\"due_date\"] <= datetime.utcnow():\n            raise ValueError(\"Due date must be in the future\")"}, {"path": "app/schemas/todo.py", "content": "from datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, Field, validator\n\nclass TodoCreate(BaseModel):\n    title: str = Field(..., min_length=1, description=\"Todo title (required, non-empty)\")\n    description: Optional[str] = Field(None, description=\"Todo description (optional)\")\n    due_date: Optional[datetime] = Field(None, description=\"Due date (optional, must be in future if provided)\")\n\n    @validator(\"due_date\")\n    def validate_due_date(cls, v):\n        if v and v <= datetime.now():\n            raise ValueError(\"Due date must be in the future\")\n        return v\n\nclass TodoUpdate(BaseModel):\n    title: Optional[str] = Field(None, min_length=1, description=\"Todo title (optional, non-empty if provided)\")\n    description: Optional[str] = Field(None, description=\"Todo description (optional)\")\n    due_date: Optional[datetime] = Field(None, description=\"Due date (optional, must be in future if provided)\")\n    completed: Optional[bool] = Field(None, description=\"Completion status (optional)\")\n\n    @validator(\"due_date\")\n    def validate_due_date(cls, v):\n        if v and v <= datetime.now():\n            raise ValueError(\"Due date must be in the future\")\n        return v\n\nclass TodoResponse(BaseModel):\n    id: int\n    title: str\n    description: Optional[str]\n    due_date: Optional[datetime]\n    completed: bool\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/database.py", "content": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlmodel import SQLModel\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\n# Database configuration\nDATABASE_URL = \"sqlite:///./todos.db\"\n\n# Create async engine\nengine = create_async_engine(DATABASE_URL, echo=True)\n\n# Create async session class\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\n# Create sync engine for metadata operations\nsync_engine = create_engine(DATABASE_URL)\n\n# Create tables\nSQLModel.metadata.create_all(sync_engine)\n\ndef get_db():\n    \"\"\"Dependency to get database session.\"\"\"\n    try:\n        db = AsyncSessionLocal()\n        yield db\n    finally:\n        db.close()\n\ndef setup_cors(app: FastAPI):\n    \"\"\"Setup CORS middleware.\"\"\"\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )"}, {"path": "app/models.py", "content": "from datetime import datetime\nfrom typing import Optional\n\nfrom sqlmodel import SQLModel, Field\nfrom sqlmodel import Relationship\n\n\nclass Todo(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(min_length=1)\n    description: Optional[str] = None\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\n    def update_timestamps(self):\n        self.updated_at = datetime.utcnow()"}, {"path": "app/schemas.py", "content": "from pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional\nfrom sqlmodel import Field as SQLField, SQLModel\n\nclass TodoBase(SQLModel):\n    title: str = Field(..., min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n    due_date: Optional[datetime] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(SQLModel):\n    title: Optional[str] = Field(None, min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n    due_date: Optional[datetime] = None\n    completed: Optional[bool] = None\n\nclass TodoRead(SQLModel):\n    id: int\n    title: str\n    description: Optional[str] = None\n    due_date: Optional[datetime] = None\n    completed: bool\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True"}, {"path": "app/routes.py", "content": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\nfrom app.database import get_session\nfrom app.repositories.todo_repository import TodoRepository\nfrom app.services.todo_service import TodoService\nfrom app.schemas.todo import (\n    TodoCreate,\n    TodoUpdate,\n    TodoResponse,\n    TodoCompleteResponse,\n)\n\nrouter = APIRouter()\n\n@router.get(\"/\", response_model=list[TodoResponse])\nasync def get_todos(\n    skip: int = 0,\n    limit: int = 100,\n    session: Session = Depends(get_session),\n) -> list[TodoResponse]:\n    repository = TodoRepository(session)\n    todos = await repository.get_all(skip=skip, limit=limit)\n    return todos\n\n@router.post(\"/\", response_model=TodoResponse, status_code=status.HTTP_201_CREATED)\nasync def create_todo(\n    todo_create: TodoCreate,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    repository = TodoRepository(session)\n    service = TodoService(repository)\n    todo = await service.create_todo(todo_create)\n    return todo\n\n@router.get(\"/{todo_id}\", response_model=TodoResponse)\nasync def get_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    repository = TodoRepository(session)\n    todo = await repository.get_by_id(todo_id)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n@router.put(\"/{todo_id}\", response_model=TodoResponse)\nasync def update_todo(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    session: Session = Depends(get_session),\n) -> TodoResponse:\n    repository = TodoRepository(session)\n    service = TodoService(repository)\n    todo = await service.update_todo(todo_id, todo_update)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> None:\n    repository = TodoRepository(session)\n    deleted = await repository.delete(todo_id)\n    if not deleted:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n\n@router.patch(\"/{todo_id}/complete\", response_model=TodoCompleteResponse)\nasync def toggle_complete(\n    todo_id: int,\n    session: Session = Depends(get_session),\n) -> TodoCompleteResponse:\n    repository = TodoRepository(session)\n    service = TodoService(repository)\n    todo = await service.toggle_complete(todo_id)\n    if not todo:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo"}, {"path": "app/auth.py", "content": "from fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\n# Configuration\nSECRET_KEY = \"your-secret-key-here\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Security utilities\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Mock user database\nMOCK_USERS_DB = {\n    \"testuser\": {\n        \"username\": \"testuser\",\n        \"full_name\": \"Test User\",\n        \"email\": \"test@example.com\",\n        \"hashed_password\": pwd_context.hash(\"testpassword\"),\n        \"disabled\": False,\n    }\n}\n\n# Authentication functions\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def authenticate_user(username: str, password: str):\n    user = MOCK_USERS_DB.get(username)\n    if not user:\n        return False\n    if not verify_password(password, user[\"hashed_password\"]):\n        return False\n    return user\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = MOCK_USERS_DB.get(username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: dict = Depends(get_current_user)):\n    if current_user[\"disabled\"]:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user"}], "dependencies": ["fastapi", "sqlmodel", "uvicorn", "pydantic", "python-multipart", "python-jose[cryptography]", "passlib[bcrypt]"]}